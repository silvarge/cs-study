# 데이터베이스의 개념적 구성 요소

## 개체 (엔티티/Entity)

데이터베이스에 표현하기 위한 유형/무형의 객체로서 서로 구별되는 것

- 현실 세계에 대해 사람이 생각하는 개념이나 정보의 단위로서 의미를 가짐
- 단독으로 존재할 수 있으며, 정보로서의 역할을 함
- 하나의 개체는 하나 이상의 속성(attribute)로 구성되고, 각 속성은 그 개체의 특성이나 상태를 기술
- 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인 것 (Thing)

### 약한 개체와 강한 개체

종속 관계에 따라 약한 객체와 강한 개체로 나뉨

- 강한 개체: 다른 개체의 도움 없이 독자적으로 존재하는 개체
- 약한 개체: 독자적으로 존재하지 않고, 상위 개체 타입을 가지는 개체

⇒ 은행이라고 생각했을 때, 고객은 강한 개체이고 계좌는 약한 개체
(고객이 계좌를 만들지 않는다면, 계좌는 독자적으로 존재할 수 없음)

## 관계 (Relationship)

개체 집합과 개체 집합 간에는 여러 유형의 관계가 존재할 수 있다

- 관계를 통해 개체들을 서로 연관시켜 어떤 의미를 나타냄 → 개체와 다름이 없다
    - 특성 상 관계는 보통 무형적으로 다루기 복잡하여 별개의 요소로 취급
- 여러 유형의 관계가 존재
    - 속성 관계: 어느 한 개체를 기술하는 속성들 간의 관계 (개체 내 관계)
    - 개체 관계: 개체 집합과 개체 집합 사이의 관계 (개체 간 관계)
- 보통 개체 관계만 명시적으로 취급하고, 속성 관계는 묵시적이고 암묵적으로 취급

이러한 개체와 관계를 도식으로 표현한 다이어그램을 **E-R 다이어그램(ERD)**이라 한다.

# 관계 데이터 모델

<img width="1053" height="412" alt="image" src="https://github.com/user-attachments/assets/e9c2798c-4256-48dc-b72b-b312574fcc3c" />

## 릴레이션 (Relation)

관계형 데이터베이스는 테이블의 모임으로 구성되며, 각 테이블은 고유한 이름을 가지고 있다.

이때, 테이블을 의미하는 단어로 사용 (NoSQL에서는 ‘컬렉션’이라고  지칭)

- 일반적으로 테이블의 각 행은 일련의 값 사이의 관계를 표현 → 테이블은 이러한 관계들의 모임
⇒ Relation
- 튜플들의 집합
- 릴레이션의 각 속성은 도메인을 가짐
    - 도메인: 허가된 값의 집

### 릴레이션 스키마와 릴레이션 인스턴스

- 릴레이션 스키마: 속성과 그 속성이 가지는 도메인의 명세
    - 차수(degree): 릴레이션 스키마에 정의된 속성의 개수 (유효한 릴레이션의 최소 차수는 1)
    - 정적 성질: 시간에 무관, 릴레이션 타입과 같은 의미
- 릴레이션 인스턴스(or 인스턴스): 릴레이션 스키마에 현실 세계의 데이터를 저장한 형태
    - 릴레이션 외연(relation extenstion)이라고도 함
    - 어느 한 시점의 릴레이션에 들어있는 내용 또는 상태 (스냅샷)
    - 동적 성질: 시간에 따라 지속적으로 변함, 릴레이션 값(보통 릴레이션)필

## 튜플 (Tuble)

- 테이블의 행

## 속성 (Attribute)

- 테이블의 열
- 한 릴레이션 내에서 속성의 이름은 모두 달라야 함

## 도메인 (Domain)

- 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

# 필드와 레코드

## 필드 (Field)

- 열 단위의 데이터
- 가장 작은 단위의 데이터
- 엔티티의 속성 표현

## 레코드 (Record)

- 행 단위의 데이터
- 필드의 집합

## 필드 타입

우선 내가 현재 가장 많이 사용하는 PostgreSQL을 기준으로 정리해 보았다.

정말 다양한 타입이 존재하는데, 일단 가장 많이 사용하는 숫자, 문자, 날짜 그리고 그 외의 일부 타입에 대해 보았다.

### 숫자 타입

| 데이터 타입 | 설명 | 바이트 수 | 숫자 범위 |
| --- | --- | --- | --- |
| SMALLINT | 작은 범위의 정수 | 2 bytes | -32768 ~ +32767 |
| INTEGER | 일반적인 정수 | 4 bytes | -2147483648 ~ +2147483647 |
| BIGINT | 큰 범위의 정수 | 8 bytes | -9223372036854775808 ~ +9223372036854775807 |
| DECIMAL/NUMERIC | 사용자 지정 정밀도, 정확도 | variable (가변) | 소수점 이전 최대 131072자리,
소수점 이후 최대 16383자리 |
| REAL | 가변적인 변수 | 4 bytes | 소수점 아래 6자리 정밀도 |
| DOUBLE PRECISION | 가변적인 변수 | 8 bytes | 소수점 아래 15자리 정밀도 |
| SMALLSERIAL | 작은 범위의 자동 증가 정수 | 2 bytes | 1 ~ 32767 |
| SERIAL | 자동 증가 정수 | 2 bytes | 1 ~ 2147483647 |
| BIGSERIAL | 큰 범위의 자동 증가 정수 | 4 bytes | 1 ~ 9223372036854775807 |

### 날짜 타입

| 데이터 타입 | 설명 | 바이트 수 | 최소값 | 최고값 | 시간 해상도(Resolution) |
| --- | --- | --- | --- | --- | --- |
| TIMESTAMP [(p)] [without time zone] | 연도, 월, 일, 시간(시, 분, 초) | 8 bytes | BC 4713 | AD 294276 | 1 ms |
| TIMESTAMP [(p)] WITH TIME ZONE | 연도, 월, 일, 시간(시, 분, 초) 및 타임존 정보 | 8 bytes | BC 4713 | AD 294276 | 1 ms |
| DATE | 연도, 월, 일 | 4 bytes | BC 4713 | AD 5874897 | 1 day |
| TIME [(p)] [without time zone] | 시간(시, 분, 초) | 8 bytes | 00:00:00 | 24:00:00 | 1 ms |
| TIME [(p)] WITH TIME ZONE | 시간(시, 분, 초) 및 타임존 정보 | 12 bytes | 00:00:00+1559 | 24:00:00-1559 | 1 ms |
| INTERVAL [fields] [(p)] | 두 날짜 또는 시간 값 사이의 간격 | 16 bytes | -178000000 years | 178000000 years | 1 ms |

- (p)는 선택적인 정밀도 값을 의미, 초의 자릿수를 저장한다 (0~6 사용 가능0
- INTERVAL은 아래 중 하나를 사용하여 저장된 데이터의 집합을 제한할 수 있다
    - YEAR
    - MONTH
    - DAY
    - HOUR
    - MINUTE
    - SECOND
    - YEAR TO MONTH
    - DAY TO HOUR
    - DAY TO MINUTE
    - DAY TO SECOND
    - HOUR TO MINUTE
    - HOUR TO SECOND
    - MINUTE TO SECOND

👉 TIMESTAMPTZ는 TIMESTAMP WITH TIME ZONE의 축약형으로 사용할 수 있지만, PostgreSQL만의 확장 기능이기에 다른 DB에서는 지원하지 않을 수 있다는 점을 생각해야 한다!

### 문자 타입

| 데이터 타입 | 설명 |
| --- | --- |
| CHARACTER VARYING(n), VARCHAR(n) | 길이 제한을 가지고 있는 가변형 |
| CHARACTER(n), CHAR(n), BPCHAR(n) | 고정 길이, blank-padded |
| BPCHAR | 가변 무제한 길이, blank-trimmed (PostgreSQL의 extenstion) |
| TEXT | 가변 무제한 길이 |

### 기타 타입

- Boolean Type

    | 데이터 타입 | 바이트 수 | 설명 |
    | --- | --- | --- |
    | BOOLEAN | 1 byte | true 또는 false, 또는 unknown의 상태를 나타낼 수 있음<BR>(unknown의 경우 SQL의 null 값을 대변) |
- Enumerate Type
    
    CREATE TYPE 이라는 명령을 사용하여 생성한다.
    
    그런데 개인적으로 나는 Spring에서 @Enumerated(EnumType.STRING)을 이용하여 VARCHAR로 저장하는 것이 테스트 할 때나, 해당 Enum에 값을 추가해야 할 때에도 편했다.
    
    이와 같이 만들면 DB를 계속 수정해야 하기에… 
    
    ```sql
    CREATE TYPE gender AS ENUM ('male', 'female');
    ```
    
- UUID
    
    UUID는 소문자 16진수 숫자들의 연속으로 작성되며, 하이픈으로 구분된 여러 그룹으로 나뉜다.
  
    구체적으로는
    
    - 8자리 숫자 그룹
    - 4자리 숫자 그룹 (3개)
    - 12자리 숫자 그룹
    
    총 32개의 숫자로 128비트를 나타낸다.
    
    ```sql
    A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11
    {a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11}
    a0eebc999c0b4ef8bb6d6bb9bd380a11
    a0ee-bc99-9c0b-4ef8-bb6d-6bb9-bd38-0a11
    {a0eebc99-9c0b4ef8-bb6d6bb9-bd380a11}
    ```
    
- JSONB
    
    JSON 데이터를 저장하는 타입
    

# 관계

## 1:1 관계 (일대일)

하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우

## 1:N 관계 (일대다)

하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우

## N:M 관계 (다대다)

여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우

일반적으로, Join 테이블을 만들어서 관리한다.

## 자기 참조 관계 (Self Referencing Relationship)

하나의 테이블 내에서 관계를 표현해야 할 수 있는 상황이 발생할 수 있다.

특정 서비스에서 회원 가입 진행 시, 추천인 ID 입력 등의 경우 등이 있다.

# 키

- 기본 키
    - 테이블의 각 튜플들을 고유하게 식별하는 키
    - 유일성과 최소성을 만족
- 대체 키
    - 후보 키 중 기본 키로 선택되지 않은 키
- 후보 키
    - 기본 키가 될 수 있는 모든 키
    - 기본 키 + 대체 키
- 슈퍼 키
    - 유일성은 만족하지만 최소성은 만족하지 못하는 키
    - 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합
- 외래 키
    - 다른 릴레이션의 기본 키로 이용되는 키
    - 참조 무결성을 위함

# 참고자료

[데이터베이스 시스템, 7 판, Abraham Silberschatz , Henry F. Korth , S. Sudarshan](https://product.kyobobook.co.kr/detail/S000001693775)

[데이타베이스론, 개정판, 이석호](https://product.kyobobook.co.kr/detail/S000000600908)

[면접을 위한 CS 전공지식 노트, 주홍철](https://product.kyobobook.co.kr/detail/S000001834833)

https://velog.io/@chappi/DB%EC%A0%95%EB%A6%AC%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A0%EA%BB%8D%EB%8B%88%EB%8B%A4.-%EA%B4%80%EA%B3%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8-Relation-Data-Model

https://www.postgresql.org/docs/current/datatype.html
