# Spring MVC 요청 생명주기

<img width="784" height="693" alt="image" src="https://github.com/user-attachments/assets/11622447-ba0f-4e46-9807-f33eae3deaa1" />

# 필터

> **J2EE 표준 스펙 기능**
> 
> 
> 디스패처 서블릿(Dispatcher Servlet)에 요청이 전달되기 전/후에 수행됨.
> 
> URL 패턴에 맞는 모든 요청에 대해 부가 작업을 처리할 수 있는 기능을 제공
> 
> 웹 컨테이너에서 동작 (WAS, 레벨에서 동작)
> 
- 스프링 빈으로 등록은 되지만, 스프링 컨테이너가 아닌 웹 컨테이너(ex. 톰캣)에 의해 관리
- 디스패처 서블릿 전/후에 처리하는 것

<img width="1158" height="564" alt="image" src="https://github.com/user-attachments/assets/79edce1b-c73e-4e61-86c5-1cec612231d1" />

## 필터의 흐름

- 올바른 전송 시: HTTP 요청 → WAS → 필터 → Dispatcher Servlet → Controller
- 전송 제한 시: HTTP 요청 → WAS → 필터 → 유효하지 못한 요청에 대한 응답 반환
    - 이 때, Dispatcher Servlet을 거치지 않고 필터 내에서 바로 반환을 진행한다.
- 다중 필터 적용 시: HTTP 요청 → WAS → 필터1 → 필터2 → 필터3 → … → Dispatcher Servlet → Controller
    - `chain.doFilter(request, response);` → 필터 체인을 통해 다음 필터 혹은 서블릿으로 제어 전달

## 필터의 메서드

> 필터를 추가하기 위해서는, `jakarta.servlet(javax.servlet)`의 Filter 인터페이스를 구현해야 한다.
> 

```java
public interface Filter {

    default void init(FilterConfig filterConfig) throws ServletException {
    }

    void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException;

    default void destroy() {
    }
}
```

- init
    - 필터 객체 초기화 및 서비스에 추가
    - 웹 컨테이너가 init 메서드를 호출하여 필터 객체를 초기화 한 후 이후 요청들은 doFilter를 통해 처리된다.
- doFilter
    - url-pattern에 맞는 모든 HTTP 요청이 디스패처 서블릿으로 전달되기 전, 웹 컨테이너에 의해 실행되는 메서드
    - 실제로 필터가 수행해야 하는 로직을 작성하는 메서드
    - doFilter의 파라미터로는 FilterChain이 있는데, FilterChain의 doFilter를 통해 다음 대상으로 요청을 전달하게 된다.
        - `chain.doFilter()` 전/후에 우리가 필요한 처리 과정을 넣어줌으로써 원하는 처리를 진행할 수 있다.
- destroy
    - 필터 객체를 서비스에서 제거하고 사용하는 자원을 반환하기 위한 메서드.
    - 해당 메서드가 호출되면, 이후에는 doFilter에 의해 처리되지 않는다.

### 🤔 그렇다면 스프링 시큐리티에서는 왜 SecurityConfig 클래스에 filterChain만 등록해도 잘 작동이 되는걸까? doFilter 이런게 없는데!

Spring Security가 DelegatingFilterProxy와 FilterChainProxy를 통해 필터의 생성, 초기화, 실행, 소멸 등 모든 과정을 자동으로 관리하기 때문에 filterChain만 등록해도 별도의 메서드 구현 없이 모든 필터가 정상적으로 동작한다.

자세한 것은 Spring Security 흐름 정리할 때!

# 인터셉터

> **Spring이 제공하는 기술 (J2EE 표준 스펙이 아님)**
> 
> 
> 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능 제공
> 
> **스프링 컨텍스트에서 동작**
> 

<img width="2000" height="1500" alt="image" src="https://github.com/user-attachments/assets/7fc91daa-e8e1-40c3-b01a-bb1d3064c004" />

- 웹 컨테이너가 아닌 Spring 내부 컨텍스트에서 처리, Spring MVC에서 제공되는 기능
- 디스패처 서블릿은 핸들러 매핑을 통해 적절한 컨트롤러를 찾도록 요청하는데,
그 결과로 실행 체인(`HandlerExecutionChain`)을 돌려준다.
    - 이 실행 체인은 1개 이상의 인터셉터가 등록되어 있다면 순차적으로 인터셉터들을 거쳐 스프링 컨테이너들을 거쳐 컨트롤러가 실행되도록 하고, 인터셉터가 없다면 바로 컨트롤러를 실행
- 컨트롤러 호출의 주체는 Dispatcher Servlet, 인터셉터가 존재하는 경우, 요청 과정에 잠시 개입하여 필요한 작업을 수행하고 Dispatcher Servlet이 컨트롤러를 호출하도로고 한다.

## 인터셉터의 메서드

> 인터셉터를 추가하기 위해서는 `org.springframework.web.servlet`의 `HandlerInterceptor`인터페이스를 구현해야 함
> 
- 필터와 비슷하지만 인터셉터는 필터보다 더 정교하고 다양한 기능을 제공
- Spring MVC에 특화된 기능을 제공하기 때문에, 특별히 필터를 사용해야 하는 상황이 아니라면 인터셉터를 사용하는 것이 더 편리하다.

```java
public interface HandlerInterceptor {

	default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {

		return true;
	}

	default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable ModelAndView modelAndView) throws Exception {
	}

	default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,
			@Nullable Exception ex) throws Exception {
	}

}
```

- preHandle
    - 컨트롤러가 호출되기 전 실행
        - 컨트롤러 이전에 처리해야 하는 전처리 작업/요청 정보를 가공하거나 추가하는 경우 사용 가능
    - 3번째 파라미터인 hander 파라미터는 핸들러 매핑이 찾아준 컨트롤러 빈에 매핑되는 HandlerMethod라는 새로운 타입의 객체, `@RequestMapping`이 붙은 메서드의 정보를 추상화 한 객체
    - 반환값이 true라면 다음 단계로 진행되지만, false라면 작업을 중단하여 이후의 작업은 진행되지 않는다.
        - 작업이 중단되는 경우, 기본적으로 body가 없는 200 OK를 반환한다.
        물론, response를 통해 개발자가 직접 설정할 수 있다.
- postHandle
    - 컨트롤러가 호출된 후에 실행
        - 컨트롤러 이후에 처리해야 하는 후처리 작업이 있을 때 사용
    - 컨트롤러가 반환하는 ModelAndView 타입의 정보가 제공되는데, 최근에는 `@RestController`를 만들면서 자주 사용되지 않는다.
    - 컨트롤러 하위 계층에서 작업을 진행하다 중간에 예외가 발생하면 postHandle은 호출되지 않는다.
    - 응답 객체 조작하기
        - `@RestController`를 사용하거나 `Controller + ResponseBody` 어노테이션을 사용할 때, 명확하게 응답을 반환하는 경우 (dto/String, Entity 등),
        인터셉터에서 객체에 대한 수정이 불가능하다.
            
            ⇒ Controller가 로직을 통해 반환한 응답을 수정하는 것 자체가 좋은 접근이 아니라고 판단하는 듯. (filter 역시 동일하게 적용)
            
        - `HttpServletResponse`는 `isCommitted` 메서드를 통해 수정이 가능한지 여부 판단 가능.
        (null이나 void와 같이 응답 결과가 없거나 이와 유사한 형태의 경우 수정이 가능)
- afterCompletion
    - 모든 뷰에서 최종 결과를 생성하는 일을 포함한, 모든 작업이 완료된 후에 실행
        - 요청 처리 중에 사용한 리소스를 반환할 때 사용하기에 적합
    - 컨트롤러 하위 계층에서 작업을 진행하다가 중간에 예외가 발생하더라도 `afterCompletion`은 반드시 호출된다.

## 인터셉터와 AOP 비교

인터셉터 대신, 컨트롤러에 적용할 부가 기능을 어드바이스로 만들어 AOP를 적용할 수도 있다.

하지만 아래와 같은 이유로 컨트롤러의 호출 과정에 적용되는 부가 기능들은 인터셉터를 사용하는 편이 낫다.

- 컨트롤러는 타입과 실행 메서드가 모두 제각각이라 포인트컷(적용할 메서드의 선별)의 작성이 어렵다
- 컨트롤러는 파라미터나 리턴 값이 일정하지 않다.
- AOP에서는 HttpSevletRequest/Response 객체를 얻기 어렵지만, 인터셉터에서는 파라미터로 넘어온다.

# 필터 VS 인터셉터

> 필터와 인터셉터 모두 비즈니스 로직과 분리되어 특정 요구사항(보안/인증/인코딩 등)을 만족시켜야 할 때 사용
> 
- `필터`는, 특정 요청과 컨트롤러에 관계없이 전역적으로 처리해야 하는 작업이나 웹 어플리케이션 전반적으로 사용되는 기능을 구현할 때 적용
- `인터셉터`는, 클라이언트의 요청과 관련된 작업에 대해 추가적인 요구사항을 만족해야 할 때 적용

| 대상 | 필터 (Filter) | 인터셉터 (Interceptor) |
| --- | --- | --- |
| 생태계 | JAVA 진영 / 서블릿 | Spring MVC |
| 관리되는 컨테이너 | 서블릿 컨테이너 | 스프링 컨테이너 |
| URL 패턴 | 서블릿 URL | 스프링 URL, 좀 더 세밀함 |
| 스프링의 예외 처리 여부 | X | O |
| Request/Response<br>객체 조작 가능 여부 | O<br>(객체 자체를 바꾸거나/랩핑이 가능<br>= 새로운 Req/Res 객체를 만들어 넘길 수 있다는 소리) | X<br>(내부 값을 수정할 수는 있지만, 새로운 것을 만들거나 하는 것은 안 됨/객체를 넘길 수 없다는 소리) |
| 용도 | - **공통된** 보안 및 인증/인가 관련 작업<br>- 모든 요청에 대한 로깅 또는 감사<br>- 이미지/데이터 압축 및 문자열 인코딩<br>- Spring과 분리되어야 하는 기능 | - **세부적인** 보안 및 인증/인가 공통 작업<br>- API 호출에 대한 로깅 또는 감사<br>- Controller로 넘겨주는 정보(데이터)의 가공 |

# 참고자료


https://dev-coco.tistory.com/173

https://mangkyu.tistory.com/173

https://velog.io/@uiurihappy/%EB%94%94%EC%8A%A4%ED%8C%A8%EC%B2%98-%EC%84%9C%EB%B8%94%EB%A6%BFDispatcher-Servlet

https://velog.io/@uiurihappy/Spring-%EC%9D%B8%ED%84%B0%EC%85%89%ED%84%B0Interceptor%EC%99%80-%ED%95%84%ED%84%B0Filter-%EC%B0%A8%EC%9D%B4

https://lealea.tistory.com/141
