# Index

## Index란?

인덱스는 데이터를 더 빨리 찾기 위해서 사용하는 자료구조다. 추가적인 구조를 만들어서 테이블에서 원하는 데이터를 더 빨리 찾을 수 있게 한다. 

책을 예시로 들어보자. 책에서 원하는 내용을 찾기 위해서는 처음부터 끝까지 전부 찾는 방법이 있을 것이다. 하지만 이 방법은 너무 비효율적이다. 대신 책 뒤편에 있는 색인에 책에서 다루는 내용을 정리해둘 수 있다. 이를 활용해서 원하는 내용을 색인에서 찾고, 거기에 적혀있는 페이지로 바로 이동하면 훨씬 효율적으로 찾을 수 있다.

데이터베이스에서도 위와 비슷한 방식으로 사용된다. 원하는 검색 키를 인덱스로 지정하면 그 검색 키와 데이터의 위치를 미리 저장해놓는다. 이후에 검색 키로 데이터를 조회할 때 인덱스를 이용해서 빠르게 원하는 데이터를 찾을 수 있다. 만약 인덱스를 사용하지 않았다면 테이블 전부를 조회해야 했을 것이고, 이는 성능의 저하로 이어질 것이다.

## 장단점

- 장점

  - 레코드를 조회하는 속도를 높일 수 있음
- 단점
  - 삽입, 삭제, 갱신 작업 작업 시 오버헤드 발생
    - 연결된 인덱스도 수정이 필요하기 때문
  
  - 인덱스를 위한 추가적인 공간이 필요함
  - 적절하지 않은 컬럼에 인덱스를 지정할 경우 오히려 성능이 저하될 수 있음
    - 중복된 데이터가 많은 컬럼에 인덱스를 지정하면 많은 데이터를 찾아봐야 함
    - 너무 큰 크기를 가진 컬럼을 지정할 경우 
  

대부분은 온라인 서비스는 읽기 작업이 쓰기 작업보다 더 큰 비중을 차지한다. 때문에 검색 속도 향상이 중요하며, 이것이 단점이 많은데도 불구하고 인덱스를 사용하는 이유이다.

인덱스를 사용하면 좋은 경우는 다음과 같다

- 규모가 큰 테이블
- 삽입, 삭제, 갱신이 자주 발생하지 않는 컬럼
- join, where, order by에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼

## 분류

인덱스는 클러스터링 인덱스와 논-클러스터링 인덱스로 나뉜다. 모든 인덱스는 검색 키를 기준으로 정렬되어 있어야 한다.

페이지는 데이터를 읽어오는 단위이다. dbms는 데이터를 디스크로부터 읽어올 때 페이지 단위로 읽어온다. 디스크 I/O는 굉장히 느리기 때문에 이를 줄이는 것이 성능 향상의 핵심적인 부분이다.  mysql의 경우 기본 페이지 크기는 16KB이다.

**클러스터링 인덱스**는 레코드를 정렬한 값으로 만드는 인덱스이다. 레코드는 하나의 기준으로만 정렬할 수 있기 때문에 테이블에 하나만 존재할 수 있며 주로 pk를 이용해서 생성한다. 리프 노드에는 실제 레코드를 담고 있는 페이지를 저장하고 있다. 검색 속도가 빠르고 연속되는 값으로 조회할 경우 순차 I/O를 사용하기 때문에 처리 속도가 빠르다. 단점으로는 정렬을 유지해야 하기 때문에 삽입, 삭제 시 많은 비용이 소모되는 점이 있다.

**논 클러스터링 인덱스**는 클러스터링 인덱스를 제외한 인덱스를 뜻하며 보조 인덱스라고도 한다. 클러스터링 인덱스와 다르게 리프 노드에 페이지가 저장된 것이 아닌 pk가 저장되어 있다. pk를 통해서 실제 데이터에 접근하기 때문에 단계를 하나 더 거쳐야 해서 상대적으로 접근 속도가 느리다. 대신 간접적으로 접근하기 때문에 데이터가 갱신되어 물리적 위치가 변해도 변경될 필요가 없어지는 장점이 있다.

mysql에서는 pk를 이용해서 클러스터링 인덱스를 자동 생성한다. pk를 지정하지 않으면 UNIQUE NOT NULL로 지정된 컬럼을 이용하고, 이것도 없으면 내부적으로 row ID가 포함된 컬럼을 하나 추가해서 이를 인덱스로 등록한다. 사용자가 인덱스를 생성할 경우 논 클러스터링 인덱스로 생성되며 논 클러스터링 인덱스의 리프 노드는 pk를 저장하고 있다. 

## B+ tree

### 특징

![b+ tree](https://velog.velcdn.com/images%2Femplam27%2Fpost%2Fbcbce100-d475-4cda-aebe-946d1813949c%2FB%ED%94%8C%EB%9F%AC%EC%8A%A4%20%ED%8A%B8%EB%A6%AC%20%EA%B8%B0%EB%B3%B8%20%ED%98%95%ED%83%9C.jpg)

인덱스를 구현하기 위해 주로 B+ tree 자료구조를 활용한다. B+ tree는 이진 트리와 달리 여러개의 자식 노드를 가질 수 있고, 한 노드에 여러 데이터를 저장할 수 있다.  B+ tree는 루트에서부터 리프 노드까지의 경로의 길이가 같은 균형 트리다. 모든 노드는 키 값과 다음 노드로 이어지는 포인터를 가지고 있으며, 리프 노드는 실제 데이터와 연결되는 포인터를 가지고 있다. 각 리프 노드들은 연결 리스트의 형태로 이어져 있다.

각 노드들의 크기는 보통 페이지 크기와 같다. 그렇기 때문에 인덱스로 지정하는 컬럼의 크기를 유의해서 지정해야 한다. 데이터의 크기가 큰 컬럼을 지정하면 하나의 페이지에 담을 수 있는 데이터의 개수가 감소하게 된다. 이렇게 되면 트리의 높이가 커져 탐색에 더 오랜 시간이 걸린다. 또한 여러 페이지를 탐색해야 할 수 있기 때문에 더욱 더 시간이 걸리게 된다. 

### 탐색

데이터를 탐색하는 과정은 다음과 같다.

- 현재 노드에서 찾으려는 값 x보다 큰 값중에 가장 작은 값 k를 찾는다
- x가 k보다 작으면 k의 왼쪽 포인터를 따라 내려간다
- x가 k와 같으면 오른쪽 포인터를 따라 내려간다
- k가 없으면 제일 오른쪽 포인터를 따라 내려간다
- 리프 노드에 도착할 때 까지 위의 과정을 반복한다
- 리프 노드에 도착하면 순차적으로 탐색하면서 x에 해당하는 데이터를 찾는다.

B+ tree는 범위 탐색에 유리하다. 예를 들어 5 < x < 10인 데이터를 찾으라는 쿼리를 보냈다고 생각해보자. 리프 노드끼리 연결 리스트로 이어져 있고 정렬이 되어있기 때문에 먼저 5을 찾고 10이 나올 때까지 연결 리스트를 따라 순차적으로 조회하면 된다.

## Hash index

![hash index](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRpMoO%2FbtqKMzdg9TX%2FXYkGt2kqE0hr9rqhHx3o3K%2Fimg.png)

해시 인덱스는 해시 테이블을 기반으로 구축한 인덱스이다. 해시 테이블은 검색 키를 해싱해서 얻은 해쉬 값으로 버킷에 접근한다. 버킷은 레코드의 주소를 저장하고 있다. 버킷에 저장된 레코드의 주소로 접근해서 데이터를 가져오는 방식으로 동작한다.

해시 충돌이 발생할 경우, 충돌이 발생한 버킷에 새 데이터를 연결 리스트로 연결해서 충돌을 해결한다.

해시 인덱스는 동등 쿼리를 효율적으로 지원한다. 해싱 과정은 O(1)로 굉장히 빠르기 때문이다. 하지만 버킷에 저장되어 있는 레코드가 정렬되어 있지 않기 때문에 범위 탐색에는 사용할 수 없다. 데이터베이스는 범위 탐색을 자주 사용하기 때문에 범위 탐색을 사용할 수 없는 해시 인덱스는 자주 사용되지 않는다.

## 생성 방법

mysql에서는 PK와 UK에 대해서는 자동으로 인덱스를 생성해준다. 수동으로는 다음과 같이 생성한다.

```sql
CREATE INDEX [인덱스명] ON [테이블명] (컬럼명); -- 보조 인덱스 생성, 중복 허용
CREATE UNIQUE INDEX [인덱스명] ON [테이블명] (컬럼명); -- 보조 인덱스 생성, 중복 허용하지 않음
```

