# 트랜잭션

데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는

한꺼번에 모두 수행되어야 할 일련의 연산

> 모든 작업이 성공하거나 아니면 모두 수행되지 않거나!
> 

## 특징 (ACID)

- 원자성 (Atomicity)
    - 모두 반영되거나 아니면 전혀 반영되지 않거나
    - All or Nothing
- 일관성 (Consistency)
    - 언제나 일관성 있는 데이터베이스 상태
    - 시스템이 가지고 있는 고정 요소는 수행 전과 완료 후의 상태가 같아야 함
- 독립성/격리성 (Isolation)
    - 둘 이상의 트랜잭션이 동시 실행될 경우, 어느 하나의 트랜잭션 실행 중에 다른 트랜잭션의 연산이 끼어들 수 없다
    - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다
- 영속성/지속성 (Durability)
    - 완료된 트랜잭션의 결과는 영구적으로 반영되어야 한다

## 트랜잭션의 상태

Active / Failed / Aborted / Partially Commited / Commited

총 5가지의 상태가 존재

<img width="950" height="309" alt="image" src="https://github.com/user-attachments/assets/fb3c2388-cc5c-4336-a13e-aa5fbafca676" />

트랜잭션 시작부터 끝날때까지

# 격리 수준 (Isolation Level)

---

트랜잭션끼리 얼마나 서로 고립되어 있는지 나타내는 수준

한 트랜잭션이 다른 트랜잭션이 변경한 데이터에 대한 접근 강도

여러 트랜잭션이 동시에 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할 지 여부를 결정하는 것

### 종류 (높-낮)

- SERIALIZABLE
- REPEATABLE READ
- READ COMMITTED
- READ UNCOMMITTED

Spring에는 그에 대한 어노테이션이 있는데(@Transactional) 위의 종류 뿐만 아니라 DEFAULT 도 존재한다 → 요 DEFAULT는 내가 사용하는 DB의 격리 수준을 따른다는 것!

- Oracle, PostgreSQL, MS SQL Server는 READ_COMMITTED
- MongoDB는 READ_UNCOMMITTED
- MySQL은 REPETABLE_READ
    
    격리 수준이 높아질수록 MySQL의 처리 성능이 많이 떨어질 것으로 예상할 수 있지만, SERIALIZABLE이 아니라면 크게 성능 개선 및 저하는 발생하지 않는다.
    
    → 결국 Undo 로그를 통해 레코드를 참조하는 과정이 거의 동일하기 때문
    
    ⇒ 따라서 MySQL은 갭 락을 통해 팬텀 리드까지 거의 발생하지 않고, READ COMMITTED보다는 정합성이 뛰어난 REPETABLE READ를 사용하는 것
    

<img width="1089" height="769" alt="image" src="https://github.com/user-attachments/assets/bd4790aa-b106-4523-bbbc-aa30b804dfdc" />

- 위로 갈수록 동시성이 강해지지만, 격리성은 약해짐
- 밑으로 갈수록 동시성이 약해지지만, 격리성은 강해짐
- 각 격리 수준마다 더티 리드, 반복 가능하지 않은 조회, 팬텀 리드가 발생할 수 있음

# 종류

---

## SERIALIZABLE

가장 엄격한 격리 수준, 트랜잭션을 순차적으로 진행시킨다.

- 여러 트랜잭션이 동일한 레코드에 동시 접근할 수 없음 → 어떠한 데이터 부정합 문제도 발생하지 않음
- 트랜잭션이 순차적으로 처리되어야 하므로 동시 처리 성능이 매우 떨어짐

순수한 SELECT 작업에서도 대상 레코드에 넥스트 키 락을 읽기 잠금(공유락)으로 건다.

가장 안전하지만 가장 성능이 떨어지므로, 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용하지 않는 것이 좋음

데드락에 걸릴 가능성이 존재한다

## REPETABLE READ (반복 가능한 읽기)

트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가 가능하다.

트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장

하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만, 새로운 행을 추가하는 것(INSERT)은 막지 않음

트랜잭션이 완료될 때까지 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능

Non-Repetable Read 문제를 해결하는 격리 수준

- 오라클은 REPETABLE READ를 지원하지 않지만, Exclusive Lock(배타적 잠금/쓰기 잠금)을 사용하여 이 문제를 해결함

## READ COMMITTED

커밋된 데이터만 조회할 수 있음

대부분의 RDBMS에서 기본적으로 사용하는 격리 수준

SELECT가 실행되는 순간, Shared Lock이 걸림. 조회 시, 실제 테이블 값이 아니라 Undo 영역에 백업된 레코드 값을 가져옴

- Undo 영역 → 트랜잭션에서 연산(commit/rollback)이 이루어지지 않아도 질의문에 의해 수정이 생기면 수정되기 이전 값이 저장되는 영역

## READ UNCOMMITTED

커밋하지 않은 데이터조차도 접근할 수 있는 격리 수준.

데이터 정합성에 문제가 생기는 격리 수준.

다른 트랜잭션의 작업이 커밋 또는 롤백되지 않아도 즉시 조회가 가능

# 격리 수준에 따라 발생할 수 있는 문제

---

|  | Dirty Read | Non-Repetable Read | Phantom Read |
| --- | --- | --- | --- |
| READ UNCOMMITTED | 발생 | 발생 | 발생 |
| READ COMMITTED | X | 발생 | 발생 |
| REPETABLE READ | X | X | 발생
(MySQL은 거의 없음) |
| SERIALIZABLE | X | X | X |

## 오손 읽기 (Dirty Read)

아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽는 것

- 트랜잭션의 작업이 완료되지 않았는데, 다른 트랜잭션에서 해당 데이터를 읽는 현상

## 반복 읽기 불가능 (Non-Repeatable Read)

하나의 트랜잭션 내에서 같은 행에 두 번 이상 조회가 발생했는데 그 값이 다른 경우

- 반복 읽기를 수행했을 때 다른 트랜잭션의 커밋 여부에 따라 조회 결과가 달라질 수 있다.
- SELECT 쿼리 실행 시 read lock을 획득하지 않거나, 획득한 lock이 SELECT 쿼리를 실행하자마자 해제될 때 발생
- 일반적인 경우 크게 문제가 되지 않지만, 하나의 트랜잭션에서 동일한 데이터를 여러 번 읽고 변경하는 작업이 금전적 처리와 연결되면 문제가 생길 수 있음
    - 입금된 총 합을 계산하는데 다른 트램잭션에서 계속 입금 내역을 커밋하는 상황의 경우 READ COMMITTED에서는 조회 시 입금 내역이 달라지므로 문제가 생길 수 있음
- 예방법
    - 트랜잭션 A가 커밋이나 롤백이 될 때 까지 트랜잭션 B의 실행을 지연하는 것
    - MVCC(다중 버전 동시성 제어)를 사용하는 것

## 유령 읽기(Phantom Read)

다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가- 안보였다가 하는 현상

⇒ 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견되는 것

MVCC를 이용해 한 트랜잭션 내에서 동일한 결과를 보장하지만, 새로운 레코드가 추가되는 경우 부정합이 생길 수 있음.

MySQL의 InnoDB 엔진을 사용할 경우 REPETABLE READ 수준에서 일반적으로는 발생하지 않음
(넥스트 키 락을 사용하기 땜시 → 갭 락이 막아줌)

- 새로운 레코드의 추가는 막지 않기 때문에, SELECT로 조회한 경우, 트랜잭션이 끝나기 전에 다른 트랜잭션에 의해 추가된 레코드가 발견되는 것
- 하지만 MVCC 덕분에 일반적인 조회에서 팬텀 리드는 발생하지 않는다. 자신보다 나중에 실행된 트랜잭션이 추가한 레코드는 무시하면 되기 때문
- 잠금이 사용되는 경우 팬텀 리드가 발생!

# 참고

---

https://mangkyu.tistory.com/299

https://akasai.space/db/about_isolation/

https://ssdragon.tistory.com/138

https://tlatmsrud.tistory.com/118

https://velog.io/@chiyongs/Transaction-Isolation-Level-%EA%B7%B8%EA%B2%8C-%EB%AD%94%EB%8D%B0
