## 📊 데이터베이스 정규화

정규화(Normalization)는 관계형 데이터베이스(RDB)의 설계에서  
✅ 데이터 중복을 제거하고, ✅ 이상 현상을 방지하고, ✅ 데이터 무결성을 유지하기 위해  
정규형에 맞도록 구조화하는 프로세스다.

정규화 과정은 각 관계(relation)가 정규형 기준을 만족하는지 평가하고,  
기준을 만족하지 못하면 필요에 따라 관계를 분해한다.

![](https://velog.velcdn.com/images/soo7132/post/f797ff51-3b61-48cd-a718-9f9563547417/image.png)

제1정규형(1NF)에서 제4정규형(4NF)로 갈수록 정규화가 더 많이 된다.

이 포스팅에서는 제1정규형,제2정규형, 제3정규형, BCNF의 각 특징을 알아보고,  
반대 개념 역정규화에 대해 살펴본다.

---

## 📌 1NF

제1정규형은 First Normal Form으로 주로 1NF로 부른다.

1NF에서

1.  **✅ 테이블의 모든 속성의 값은 원자적이어야 한다.**
    -   '원자적인 값'은 더 이상 분해될 수 없는 단일값을 말한다.
2.  **✅ 각 행은 고유해야 한다.**
    -   중복된 행이 없어야 한다.

**\[1NF를 지키지 않은 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/b9652b92-a3c3-48c0-90d0-31d9c5949f17/image.png)

각 부서의 위치를 나타낸 Dlocation 속성에 {Bellaire, Sugarland, Houston}과 같이 여러 값이 배열 형태로 들어있다.

이러한 경우에는 삭제, 업데이트 이상현상(Anomaly) 등이 나타날 수 있다.

  
한 컬럼에 여러 값이 들어있지만 DB는 컬럼 하나에 들어간 여러 값을 하나의 문자열로 인식하기 때문이다.  
'Houston'이라는 하나의 값만 지우고 싶은데 DB에서는 'Bellaire, Sugarland, Houston' 이렇게 하나의 값이므로 개별적으로 데이터를 삭제할 수 없다.  
결국 전체 문자열을 덮어씌워야 하는데 불편하고 실수가 일어날 가능성이 커진다.  
업데이트하는 경우도 마찬가지이다.

**\[1NF를 지킨 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/efec8772-0e1a-4a66-9f97-b994bb35e802/image.png)

Dlocations 컬럼만 따로 DEPT\_LOCATIONS 테이블로 따로 분리해서 관계를 생성했다.  
DEPARTMENT의 Dnumber라는 PK를 FK로 가지며 연결되고  
두 테이블은 모든 컬럼이 원자적이고, 중복되는 행이 없으므로 1NF를 지켰다.

++ 따로 테이블로 분해하지 않고, 각 컬럼의 값이 원자적이도록 개별 행으로 분리하는 방법도 가능하다.

---

## 💡 Functional Dependency(FD)

2NF, 3NF, BCNF는 함수적 종속성(funtional dependencies) 개념을 먼저 알아야 한다.

> "X -> Y: X functionally determines Y"

함수적 종속성은 **X가 Y를 함수적으로 결정한다**는 뜻으로 X → Y로 표현한다.

X→Y 관계가 있고  
**서로 다른 두 튜플이 있을 때, 만약 두 튜플의 X 컬럼의 값이 서로 같다면**  
**Y 컬럼의 값도 같아야 한다.**

예를 들어, 출석부 테이블이 있다고 할 때 학번이 같으면 이름과 전공이 같을 것이다.  
학번 → 이름, 학번 → 전공 관계가 성립한다.

X를 결정자, Y를 종속자라고 부른다.

---

## 📌 2NF

제2정규형의 조건은

1.  **✅ 제1정규형을 만족한다.**
2.  **✅ 모든 컬럼이 완전 함수 종속을 만족한다. (부분 종속성을 제거됐다고도 한다.)**

**"완전 함수 종속"**이란,  
후보 키 K와 K에 속하지 않는 속성 A가 있을 때, A를 결정하기 위해 K의 일부가 아닌 "K 전체"를 참조해야만 한다는 뜻이다.

X→Y의 관계에서 X의 진부분집합 어떤 것도 Y를 결정하지 못할 때

즉, **Y를 결정하려면 X 전체가 필요한 상태**를 말한다.

예시를 보자.

**\[2NF를 지키지 않은 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/7af11da8-23e7-4556-a501-988698d7aec1/image.png)

참고로 각 행이 중복되지 않고, 모든 컬럼이 원자적이므로 1NF는 만족했다.

이 테이블의 [후보 키](https://ko.wikipedia.org/wiki/%ED%9B%84%EB%B3%B4_%ED%82%A4)는 {종업원, 기술} 세트이다.

그렇다면 완전 함수 종속 정의에 따라  
후보 키에 속하지 않는 나머지 속성 {근무지}의 값이 결정되려면  
후보 키의 전체 요소 {종업원, 기술}의 의해 결정되어야 한다.

하지만 현재 이 테이블은 후보 키의 일부분인 {종업원}에만 영향을 받아 2NF를 위반하고 있다.

**\[2NF를 지킨 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/8ec9acd1-bd4d-433e-ae1e-8aa759223a2f/image.png)

이 테이블을 {종업원} 후보 키를 갖는 "종업원" 테이블과 {종업원, 기술} 후보 키를 갖는 "종업원의 기술" 테이블로 분리하자.

"종업원" 테이블에서 근무지는 유일한 후보키 {종업원}에 의해서 결정되고(종업원→근무지),  
"종업원의 기술" 테이블에서는 후보 키 {종업원, 기술} 외에는 다른 컬럼이 없으니 완전 함수적 종속성을 따른다고 볼 수 있다.

이렇게 2NF를 적용하면 다음과 같은 효과가 있다.

-   삽입 이상현상 해결, 데이터 중복 제거: 한 종업원이 여러 기술을 가질 때 근무지 정보가 중복 저장될 필요가 없다.
-   삭제 이상현상 해결: 종업원의 기술을 삭제해도, 종업원의 근무지 정보가 사라지지는 않는다.
-   갱신 이상현상 해결: 종업원의 근무지가 변경될 경우 "종업원" 테이블의 한 행만 수정하면 된다.

---

## 📌 3NF

제3정규형은

1.  **✅ 제2정규형을 만족한다.**
2.  **✅ 테이블 내의 키가 아닌 모든 컬럼이 테이블의 모든 키에 이행적 종속이 되지 않는다.**

**"이행적 함수적 종속"**이란  
어떤 속성 A가 속성 B을 통해 속성 C을 결정하는 경우, A → B → C라면 A → C가 성립하게 되는 상황이다.  
C는 B에 의존하고, B는 A에 의존하는 이행 함수적 종속을 제거해야 한다.

**\[3NF를 지키지 않은 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/13dcff14-e5a8-486b-a6f3-83aa6948d0ec/image.png)

이 테이블에서 후보 키는 {대회, 연도}이다.

{우승자}는 {대회, 연도}로 결정된다.  
{우승자 생년 월일}은 {우승자}에 의해 결정된다.  
{대회, 연도}를 알면 우승자를 통해 {우승자 생년 월일}도 알 수 있다.

{대회, 연도} -> {우승자} -> {우승자 생년 월일}로 이어지고  
{대회, 연도} -> {우승자 생년 월일}도 성립하는  
이행 함수적 종속이 존재한다.

**\[3NF를 지킨 경우\]**

![](https://velog.velcdn.com/images/soo7132/post/29c36f8d-dc62-4293-a27f-856b92e91fbd/image.png)

"대회 우승자"와 "우승자 생년 월일" 테이블로 분리한다.

이렇게 3NF를 해결하면

-   삽입 이상현상 해결, 데이터 중복 제거: 우승자가 여러 대회에서 이겨도, 생년 월일 정보는 여러 대회에서 중복 입력할 필요가 없다.
-   갱신 이상현상 해결: 대회 이름이나 연도가 변경될 경우 "대회 우승자" 테이블만 바꾸면 된다.

---

## 📌 BCNF

보이스-코드 정규형 Boyce-Codd Normal Form는 3NF에서 더 엄격해진 형태로

1.  **✅ 제3정규형을 만족한다.**
2.  **✅ 모든 함수적 종속이 후보 키에 의해서만 결정되어야 한다. (모든 결정자는 후보키다.)**

테이블에 A→B라는 함수적 종속 관계가 있다면  
이때 반드시 A는 후보 키여야 한다.

만약 A가 후보 키가 아닌 다른 속성이라면 BCNF를 만족하지 못한다.

데이터 중복을 최소화하기 위한 방법이다.

---

## 💡 역정규화

정규화 과정이란 앞서 말한대로  
'각 관계(relation)가 정규형 기준을 만족하는지 평가하고,  
기준을 만족하지 못하면 필요에 따라 관계를 분해를 반복하는 과정'이다.

### 역정규화가 필요한 상황

개발 요구사항에 따라  
1NF에서 멈출 수도, 2NF에서 멈출 수도 있지만  
데이터 중복과 이상 현상을 줄이고 데이터 무결성을 보장하기 위해 분해를 반복하다 보면  
처음보다 아주 많은 테이블이 추가로 생길 수 있다.

⚠️ 이 경우 테이블 간 join이 아주 많아져 쿼리 요청을 처리하는 시간이 매우 증가하여  
성능이 떨어질 수 있고 많은 테이블을 관리하기 힘들어질 수 있다.

  
특히, 데이터 조회가 빈번한 **"읽기 중심의 시스템"**에서는 한 테이블에서 중복된 값들을 가져오는 것보다 여러 테이블을 조인하는 것이 크게 부담이 될 수 있다.

-   읽기(데이터 조회)가 빈번할 때
-   대량의 데이터를 처리해야 할 때
-   데이터 조회 속도가 빨라야 할 때

이 상황에는 역정규화를 고려해보자.

### 역정규화 적용 시 고려 사항

데이터 중복 제거, 이상현상 해결, 데이터 무결성 관리를 목표로 정규화를 진행해왔다.

반대로 역정규화를 할 때는 이러한 점들이 크게 문제가 되지 않도록 고려해야 한다.

-   쓰기 성능 저하: 역정규화는 읽기 성능은 좋아질 수 있지만, 데이터가 자주 변경되는 쓰기 중심의 시스템에서는 입력할 데이터가 많아지므로 성능이 나빠질 수 있다.
-   삭제의 어려움: 모든 중복된 데이터를 찾아 삭제해야 한다.
-   수정의 어려움: 많은 중복 데이터를 가질 수 있기 때문에 하나의 데이터가 수정되면 여러 위치에서 수정해야 할 수 있다.
-   데이터 무결성: 데이터 중복으로 일관성 있는 갱신이 어려울 수 있다.

### 역정규화 장단점

지금까지의 내용을 토대로 다음과 같이 장단점을 정리할 수 있다.

**✅ 장점**

-   쿼리 성능 향상
    -   여러 테이블을 JOIN하지 않고 데이터를 직접 조회할 수 있으므로, 읽기 성능이 크게 향상될 수 있다.
    -   빠른 데이터 조회가 필요한 시스템에서 좋다.
-   단순한 쿼리
    -   하나의 테이블만 조회하는 단순한 쿼리로 데이터를 조회할 수 있기 때문에, 쿼리 작성이 편리해진다.

**⛔ 단점**

-   데이터 중복
    -   데이터를 중복 저장하므로, 불필요한 정보도 많아져 저장공간이 낭비된다.
-   이상현상 재발
    -   데이터 갱신 시 같은 값을 지닌 모든 위치에서 갱신해야 한다.
    -   한 데이터를 삭제할 때 중복된 데이터를 모두 삭제하지 않으면 일부 데이터가 남을 수 있다.
    -   데이터 무결성, 일관성 ↓
-   쓰기 성능 저하
    -   데이터를 수정할 때 중복된 데이터 모두를 수정하며 작업이 여러 번 일어날 수 있다.
    -   데이터 삽입, 수정, 삭제가 빈번한 시스템에서는 역정규화로 성능이 저하될 수 있다.

---

## 참고자료

> 📕 Fundamentals of Database Systems, 2017, Ramez Elmasri and Shamkant B.Navathe  
> [\[Database\] 정규화(Normalization)란?](https://velog.io/@sukyeongs/Database-Normalization)  
> [위키백과 제2정규형](https://ko.wikipedia.org/wiki/%EC%A0%9C2%EC%A0%95%EA%B7%9C%ED%98%95)  
> [위키백과 제3정규형](https://ko.wikipedia.org/wiki/%EC%A0%9C3%EC%A0%95%EA%B7%9C%ED%98%95)  
> [\[DB\] 정규화, 역정규화](https://velog.io/@calis_ws/DB-%EC%A0%95%EA%B7%9C%ED%99%94-%EC%97%AD%EC%A0%95%EA%B7%9C%ED%99%94)  
> +데이터베이스 전공 강의와 코드잇 스프린트 강의를 듣고 추가 학습한 내용입니다.
