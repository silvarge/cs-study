## 가비지 컬렉션이란? (Garbage Collection, GC)

C/C++ 같은 언어에서는 개발자가 직접 \`free()\` 함수를 호출하여 사용이 끝난 메모리를 해제해야 했습니다.

그러나 Java에서는 JVM의 가비지 컬렉터가 주기적으로 검사하여 불필요한 메모리를 알아서 정리해주기 때문에 그럴 필요가 없습니다.

가비지 컬렉션이란,

JVM의 Heap 영역에서 동적으로 할당했던 메모리 중

필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 과정입니다.

-   **메모리 누수 방지**: 개발자가 메모리 해제를 잊어버려 프로그램이 비정상적으로 종료되거나 성능이 저하되는 현상(OOM 에러)을 GC가 자동으로 방지합니다.
-   **개발 생산성 향상**: 개발자가 메모리 해제 로직 대신 비즈니스 로직에 집중할 수 있습니다.

---

## 가비지 컬렉션 대상

가비지 컬렉션은 힙(Heap) 영역에서 동작합니다.

자바에서 \`new\` 키워드를 사용하여 생성되는 모든 객체의 실제 데이터가 저장되는 공간이기 때문에

더 이상 필요 없는 객체들은 힙 영역에 있습니다.

GC는 어떤 객체가 쓰레기인지 판단할 때 접근 가능성(Reachability)을 기준으로 합니다.

-   **Reachable**: 객체가 참조되고 있는 상태
    -   스택 영역이나 메서드 영역 같은 영역에서부터 시작하여 레퍼런스가 있는 상태
-   **Unreachable**: 객체가 참조되고 있지 않은 상태
    -   어떤 참조에서도 도달할 수 없는 객체는 더 이상 사용되지 않는 가비지로 판단하여 GC의 수집 대상이 됩니다.

<img width="1159" height="578" alt="image" src="https://github.com/user-attachments/assets/4fcc13d4-53fd-43bc-a076-a164aca8a1e2" />

GC 때마다 모든 객체의 접근 가능성을 매번 검사하는 것을 비효율적입니다.

자바의 GC는 세대 가설(Generational Hypothesis)라는 전략을 채택하여 힙 메모리를 세대별로 나누어 관리하고 있습니다.

-   대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
-   오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

이러한 이론을 기반으로, **세대 가설**은

**대부분의 객체는 매우 짧은 시간 동안만 사용되고 소멸되는 일회성이고, 오래 살아남은 객체는 아주 오랫동안 사용된다**는 가설입니다.

이 가설을 바탕으로 힙 영역을 두 공간으로 나눕니다.

-   **젊은 세대(Young Generation)**
    -   새롭게 생성된 객체가 할당되는 영역
    -   대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 이곳에 있다가 소멸
    -   객체가 빠르게 소멸된다는 가설에 따라 가비지 컬렉션이 매우 자주 발생
    -   젊은 세대에 대한 가비지 컬력센을 **Minor GC**라고 부름
-   **오래된 세대(Old Generation)**
    -   젊은 세대에서 여러 번의 Minor GC를 견뎌내어 윗세대로 승격된(Promotion), 오래 살아남은 객체들이 위치한 영역
    -   가비지 컬렉션이 상대적으로 덜 발생
    -   오래된 세대에 대한 가비지 컬렉션을 **Major GC** 또는 **Full GC**라고 부름

이러한 세대별 분할을 통해 GC는 전체 힙을 검사하는 대신,

객체가 빠르게 죽는 Young Generation에 집중하여 전체적인 GC 성능을 올립니다.

---

## 가비지 컬렉션 동작 방식

### 🛑 Stop The World

-   가비지 컬렉션을 실행하기 위해 JVM이 애플리케이션의 실행을 멈추는 작업

GC가 실행될 때는 GC를 실행하는 스레드를 제외한 모드 스레드들의 작업이 일시적으로 중단됩니다.

GC가 완료된 후 작업이 재개됩니다.

### 🧹 Mark and Sweep

**Mark-Sweep**은 가비지 컬렉션이 동작하는 기본적인 청소 과정입니다.

Stop The World를 통해 모든 작업을 중단시킨 후 GC는 사용되지 않는 객체가 있는지 탐색합니다.  
Unreachable한 객체들은 삭제할 메모리로 Mark합니다.  
이렇게 Mark된 객체들을 메모리에서 삭제하는 것을 Sweep이라고 합니다.

-   Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업  
    -   그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹
-   Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
    -   Unreachable 객체들을 Heap에서 제거
-   Compact(Optional): 파편화된 메모리 영역을 앞에서부터 채워나가는 작업
    -   Sweep 후에 메모리에서 일부 객체들이 삭제되면 빈 공간들이 여기저기 흩어진, 파편화된 상태가 됩니다.
    -   이 빈 공간을 모으기 위해 살아남은 객체들을 메모리 시작점으로 이동시켜 연속된 빈 여유 공간을 만듭니다.

---

## 가비지 컬렉션의 단점

가비지 컬렉터가 자동으로 청소를 해준다는데

이 메모리가 언제 해제되는지 개발자가 정확히 알 수 없어 제어하기 힘들며,

가비지 컬렉션이 실행하는 동안에는 다른 동작을 멈추기 때문에(Stop The World) 오버헤드가 발생할 수 있습니다.

실시간성이 중요한 프로그램이라면 가비지 컬력센이 너무 자주 일어난다면 성능 문제가 도드라질 수 있습니다.

따라서 서비스 이용에 차질이 생길 수 있어 이 Stop The World 시간을 최소화하는 것이

가비지 컬렉션 성능 개선의 주요 포인트입니다.

이러한 작업을 GC 튜닝이라고 합니다.

---

참고자료

-   [☕ 가비지 컬렉션 동작 원리 & GC 종류 💯 총정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#%EA%B0%80%EB%B9%84%EC%A7%80_%EC%BB%AC%EB%A0%89%EC%85%98_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98_%EC%A2%85%EB%A5%98)

-   [\[Java\] Garbage Collection(가비지 컬렉션)의 개념 및 동작 원리 (1/2)](https://mangkyu.tistory.com/118)
