자세한 내용은 각자를 주제로 할 때 다루는 것으로 하고,
여기서는 조금 더 가볍게 다루는 것을 목표로 한다.

<img width="1493" height="1511" alt="image" src="https://github.com/user-attachments/assets/bb3e56e2-abc3-4e77-aa65-39e2156e3b96" />

# 비선형 자료 구조

이름 그대로 ***선형 자료 구조가 아닌 자료 구조***를 말한다.

데이터가 계층적이거나 비순차적으로 연결된 구조

## 그래프(Graph)

> 정점(Vertex)와 간선(Edge)의 집합 (G = (V, E))
> 

노드(정점)와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료구조

### 그래프 용어

- 정점(Vertex/Node): 위치라는 개념
- 간선(Edge): 위치 간의 관계, 노드를 연결하는 선
- 인접 정점: 간선에 의해 직접 연결된 정점
- 차수(Degree): 노드에 인접한 간선의 수
    - 방향 그래프: 진입 차수와 진출 차수로 구분
        - 진입 차수(내차수): 방향 그래프에서 외부에서 오는 간선의 수
        - 진출 차수(외차수): 방향 그래프에서 외부로 향하는 간선의 수
    - 무방향 그래프에 존재하는 정점의 모든 차수의 합은 그래프 간선 수의 2배
    (방향이 없으니 양방향 모두 성립)
- 단순 경로: 경로 중에서 반복되는 정점이 없는 경우
- 사이클: 단순 경로의 시작 정점과 종료 정점이 동일한 경우

### 그래프의 특징

> 그래프는 네트워크 모델이다
> 

그래프는 여러 가지 특징을 가질 수 있다.
하지만, 하나의 그래프가 모든 특징을 가지는 것이 아닌 특징에 따라 그래프의 종류가 나누어진다.

- 무방향성: 그래프의 간선은 방향성이 없을 수 있으며, 양쪽 방향으로 모두 이동할 수 있다.
    - 특정한 방향이 없다고 생각하면 된다. 양방향이라는 뜻
- 방향성: 그래프의 간선은 방향성이 존재할 수 있으며, 한쪽 방향으로 모두 이동할 수 있다.
- 가중치: 그래프의 간선에는 가중치를 부여할 수 있다.
    - 보통 거리, 비용, 우선순위 등을 나타내는 데 사용
- 연결성: 노드 간 경로가 존재하면 두 노드는 연결되었다고 한다.
- 사이클: 한 노드에서 시작하여 경로를 따라가며 마침내 자기 자신으로 돌아오는 경로를 사이클이라고 하는데, 이러한 사이클이 존재하는 그래프를 순환 그래프라고 한다.
- 차수: 한 노드에 인접한 간선의 수
    - 무방향 그래프: 노드의 차수 = 연결된 노드의 수
    - 방향 그래프: 인접한 노드의 수와 나가는 노드의 수로 구분됨

### 그래프의 종류

이 외에도 특징에 따라 다양한 종류의 그래프들이 존재한다.

- 방향 그래프: 간선에 방향이 있는 그래프
    - <a, b> = a - b
- 무방향 그래프: 간선에 방향이 없는 그래프
    - (a, b) = a → b
- 가중치 그래프: 간선에 가중치가 부여된 경우

## 트리(Tree)

> 계층적인 자료를 표현하는 데 사용되는 자료구조
> 

그래프의 한 종류라고도 말할 수 있다.
(사이클이 없는 하나의 연결 그래프 혹은 DAG(방향성이 있는 비순환 그래프)의 한 종류)

<img width="1225" height="1092" alt="image" src="https://github.com/user-attachments/assets/9ba9e48b-bb98-4bb4-a67c-c258a0a6ead5" />

여기에 조금 더 추가하자면

- 형제 노드(Sibling Node): 트리의 같은 레벨 선상에 있고 같은 부모를 가지는 노드들
- 조상 노드(Ancestor Node): 간선을 따라 루트 노드까지 가는 경로 상에 있는 모든 노드들
- 서브 트리: 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
    - 노드가 한 개더라도 트리라고 할 수 있다
- 깊이(Depth): 루트 노드로부터의 거리
- 높이(Height): 트리의 깊이 중 최댓값 (가장 깊은 노드의 깊이)
- 차수(Degree): 각 노드가 가진 자식 노드의 개수

### 트리의 종류

그래프처럼 트리도 특징에 따라 종류가 나뉘는데, 가장 많이 언급되고 사용되는 부분에 대해 다뤄보았다.

- 이진 트리 (Binary Tree)
    
    > 각 노드가 최대 두 개의 자식을 갖는 트리
    > 
    - 중위/전위/후위 순회를 통해 이진 트리를 순회할 수 있다.
    - 이진 트리의 종류
        
        
        | 종류 | 설명 | 사용처 |
        | --- | --- | --- |
        | 전이진 트리<br>(Full Binary Tree) | 트리의 모든 노드가 0개 혹은 2개의 자식 노드를 가지는 이진 트리 | 암호화 알고리즘 |
        | 포화 이진 트리 | 트리의 내부 노드가 2개의 자식을 가지며 모든 리프 노트가 같은 레벨에 있는 이진 트리 | 데이터 정렬, 우선순위 큐 및 트리 기반 알고리즘 |
        | 완전 이진 트리 | 트리의 모든 레벨이 완전히 채워져 있지는 않지만 마지막 레벨을 제외한 모든 레벨에서 왼쪽으로 차례대로 채워진 이진 트리 | 힙 구조 |
        | 편향 이진 트리 | 트리의 모든 노드가 한 쪽(왼쪽, 오른쪽)으로만 자식을 가지는 이진 트리 | - |
        | 균형 이진 트리 | 트리의 모든 내부 노드의 두 자식 서브 트리의 높이 차이가 1 이하인 이진 트리 | 검색/삽입 작업 |
        | 이진 힙 | 트리의 각 노드가 자식 노드보다 작은 값을 가지는 최소 힙이거나 각 노드가 자식 노드보다 큰 값을 가지는 최대 힙 형태를 가지는 이진 트리 | 우선순위 큐 |
- 이진 탐색 트리 (Binary Search Tree, BST)
    
    > 정렬된 이진 트리, 중복된 키를 허용하지 않음
    > 
    
    노드의 오른쪽 하위 트리에는 ‘노드 값보다 큰 값’이 있는 노드만 포함되고,
    왼쪽 하위 트리에는 ‘노드 값보다 작은 값’이 있는 노드만 포함되는 트리
    
- 균형 트리
    
    
    | 종류 | 설명 | 검색/삽입/삭제 시간 복잡도 |
    | --- | --- | --- |
    | AVL 트리 | 노드의 ‘왼쪽 서브트리와 오른쪽 서브트리의 높이 차이가 1을 넘어가지 않도록 유지’하는 형태의 균형 이진 탐색 트리 | O(logN) |
    | 레드-블랙 트리 | 노드가 레드 또는 블랙인 색깔을 가지며, 특정한 규칙을 따르는 균형 이진 탐색 트리 | O(logN) |
    | B-트리 | 노드가 정렬된 데이터를 유지하면서 효율적인 삽입, 삭제 및 검색 작업을 수행하는 자기 균형 탐색 트리 | O(logN) |

## 그래프와 트리의 차이

|  | 그래프 | 트리 |
| --- | --- | --- |
| 정의 | 노드와 그 노드를 연결하는 간선을 하나로 모아 놓은 자료 구조 | 그래프의 한 종류,<br>DAG(Directed Acyclic Graph)의 한 종류 |
| 방향성 | 방향 그래프, 무방향 그래프 | 방향 그래프 |
| 사이클 | 사이클 가능, 자체 간선 가능, 순환/비순환 그래프 모두 존재 | 사이클 불가능, 자체 간선 불가능, 비순환 그래프 |
| 루트 노드 | 루트 노드의 개념이 없음 | 한 개의 루트 노드만이 존재,<br>모든 자식 노드는 하나의 부모 노드만을 가짐 |
| 부모-자식 | 부모-자식 개념이 없음 | 부모-자식 관계, top-bottom 혹은 bottom-top으로 이루어짐 |
| 모델 | 네트워크 모델 | 계층 모델 |
| 순회 | DFS, BFS | DFS, BFS 안의 Pre-, In-, Post-Order |
| 간선의 수 | 그래프에 따라 간선의 수가 다름, 간선이 없을 수도 있음 | 노드가 N인 트리는 항상 N-1의 간선을 가짐 |
| 경로 | - | 임의의 두 노드 간 경로는 유일함 |
| 예시 | 지도, 도로, 선수 과목 | 이진 트리, 이진 탐색 트리, 균형 트리, 이진 힙 등 |

## 해시 테이블

> (Key, Value) 형식으로 이루어져 있고, Key 값에 해시 함수를 적용해 고유한 Index를 생성하여 저장하는 자료 구조
> 

> 공간을 팔아서 시간을 사다
> 
- 데이터를 담을 테이블을 미리 확보해 놓은 후, 입력받은 데이터를 해시하여 테이블 내의 주소를 계산하고 주소에 데이터를 담는 자료구조
    - 데이터 - (해시 함수) → 해시값(=인덱스)
- Key와 실제 데이터의 값이 한 쌍으로 존재(Key, Value) - Key 값이 배열의 인덱스로 변환
    - 실제 값이 저장되는 장소를 버킷 혹은 슬롯이라 함
- 특정한 값을 Search하는 데 데이터 고유의 인덱스로 접근하게 됨
- 특정 데이터가 저장되는 인덱스는 그 데이터만의 고유한 위치
⇒ 삽입 연산 시 다른 데이터의 사이에 끼어들거나 삭제 시 다른 데이터로 채울 필요가 없어 연산에서 추가적인 비용이 없도록 만들어진 구조
- 평균 시간복잡도 = O(1) / 최악의 경우 = O(n)

### 해시 함수

Key 값에 해시 함수를 돌려 고유한 인덱스 값을 얻을 수 있도록 하는 것이 중요하다.
그 방법에도 여러 가지가 존재한다.

1. Division Method (나눗셈법)
    - 입력값을 테이블의 크기로 나누어 계산 ( 주소 = 입력값 % 테이블의 크기)
    - 테이블의 크기를 소수로 정하고, 2의 제곱수와 먼 값을 사용해야 효과가 좋다고 알려짐
2. Digit Folding (자릿수 접기)
    - 각 Key의 문자열을 아스키코드를 변환하여 값을 합한 데이터를 테이블 내 주소로 사용
3. Multiplication Method (곱셈법)
    - 숫자로 된 Key 값과 0과 1사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 계산을 수행
    - h(k) = (kAmod1) * m
4. Univeral Hashing
    - 다수의 해시 함수를 만들어 집합 H에 넣어두고, 무작위로 해시 함수를 선택해 해시값을 만드는 기법

### 해시 충돌

Key 값은 다르지만 해시 함수를 통해 나온 값이 같을 경우, 충돌이 발생했다고 한다.
해시 충돌을 해결하기 위한 다양한 방법이 존재하지만, 가장 기본적인 두 가지 방법이 존재한다.

- **개방 주소법 (Open Addressing)**
    
    해시 충돌이 발생하면, 다른 해시 버킷에 해당 자료를 삽입하는 방식
    해시 테이블 안에서 현재 사용되지 않는 공간을 찾는 방법
    
    충돌이 발생하면 데이터를 저장할 장소를 찾아 돌아다니다 데이터를 입력한다.
    저장할 장소를 찾는 과정에 여러 방법이 존재한다.
    
    - 특징
        - 적은 양의 데이터에 효과적
        - 메모리 효율이 분리 연결법에 비해 좋음
        - 메모리 할당에 대한 오버헤드가 없음
        - 분리 연결법에 비해 캐시 효율이 좋음
        - 테이블의 확장이 필요할 수 있음
    - 저장할 장소를 찾는 방법
        - 선형 탐사: 정해진 고정 폭만큼 건너뛰다 비어 있는 공간 발견하면 넣음
            - 단순해서 계산하기 쉬움
            - 캐시의 효율이 높다
            - 최악의 경우 탐색을 시작한 위치까지 돌아옴
            - 특정 해시 값 버킷 근처 버킷이 모두 채워져 평균 탐색 시간이 늘어남 (Primary Clustering)
        - 제곱 탐사: 해시의 저장 폭을 제곱으로 저장하는 방식
            - 선형 탐사에 비해 폭넓게 탐사해 탐색, 삭제에 효율적
            - Secondary Clustring 문제 발생
                - 처음 충돌한 위치가 같다면, 다음 충돌할 위치에서도 반복적으로 계속 충돌이 난다는 의미
        - 이중 해싱/재해싱: 2차 해시 함수로 다시 해싱을 해서 새로운 주소 할당
            - 클러스터링에는 큰 영향을 받지 않음
            - 값이 퍼지게 되어 캐시의 측면에서는 비효율적
            - 한 번 더 해싱해야 하기 때문에 연산량이 많이 든다
- **분리 연결법 (Separate Chaining)**
    
    해시 충돌이 발생하면 하나 이상의 값을 저장할 수 있도록 변경된 버킷에 데이터를 추가
    해시 테이블의 구조를 바꾸는 방법 (하나의 위치가 여러 개의 항목을 저장할 수 있도록)
    
    - 연결 리스트 사용 (Linked List)
        - 각각의 버킷들을 연결리스트로 만들어 충돌 발생 시 해당 버킷의 리스트에 추가
        - 삽입/삭제가 간단하지만 작은 데이터들을 저장할 때 연결리스트 자체의 오버헤드가 부담될 수 있음
        - 개방 주소법에 비해 테이블의 확장을 늦출 수 있음
            - 확장 시 O(m) (m: key의 개수)의 시간복잡도 필요
    - 트리 사용 (Red-Black Tree)
        - 트리는 기본적으로 메모리 사용량이 많아 데이터가 많을 때 사용
        - Java 8 기준, 하나의 해시 버킷의 데이터가 8개가 넘으면 트리로 전환, 6개가 되면 다시 연결리스트로 전환 (해시 크기가 64(default)가 넘어야지 전환이 됨)
            - 7에서 전환하지 않는 이유는, 1개 단위로 하면 오버헤드가 더 크기에 소요 비용을 감소시키기 위함
        - Red-Black 트리를 사용하는 이유
            - 조금 더 느슨하게 균형을 유지하되 조회, 삽입, 삭제에 평균적으로 좋은 성능을 보여주기에
            - AVL 트리는 계속 확실하게 밸런스를 유지해야 하는데, 그 정도로 조회만 많이 일어나는 것이 아니라 이런 균형을 유지하는 데 드는 비용 등을 고려하였을 때 RB 트리를 사용

## 우선순위 큐

우선순위의 개념을 큐에 도입한 자료 구조

- 데이터들이 우선 순위를 가지고 있고, 우선 순위가 높은 데이터가 먼저 나감
- 일반적으로 힙을 이용하여 구현하는 경우가 많다

## 힙(Heap)

> 각 노드의 값이 해당 노드의 자식보다 큰(또는 작은) 완전 이진 트리
> 
- 우선순위 큐를 구현하거나 힙 정렬을 하기 위해 사용하는 자료 구조
(힙의 응용 중 대표적인 것이 우선순위 큐)
- 가장 크거나 작은 값을 찾아내는 연산을 빠르게 할 수 있음 (최대/최솟값 검색에 큰 장점)
- (최대 힙을 가정) 큰 값이 위에 있고 작은 값들은 아래에 있는 트리, 느슨한 정렬 상태를 유지
    - 삽입 시 항상 왼쪽부터 채워짐
    - 형제 간 우선순위가 없음
    - 루트 노드는 가장 큰 값을 가짐

### 힙의 종류

- 최대 힙(Max Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 힙
- 최소 힙(Min Heap): 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 힙

### 힙의 시간복잡도

- 삽입: O(logN)
- 삭제: O(logN)
- 최댓값(혹은 최솟값) 추출: O(1) ← 루트 노드 찾으면 되기 때문

## 맵(Map)

> Key와 Value 한 쌍으로 이루어진 자료 구조
> 
- 키와 값이 한 쌍으로 이루어져 있어, 키를 통해 값에 접근할 수 있도록 만들어진 자료 구조
- Key의 중복을 허용하지 않음 (Key를 통해 접근하기 때문)

### Java에서 사용되는 대표적인 Map

- HashMap
    - Key와 Value의 쌍으로 구성
    - 자료구조 안에 묶인 쌍들에 대한 순서는 보장할 수 없음
- TreeMap
    - Key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조
    - Key값을 통한 탐색 뿐 아니라 Key 값의 정렬을 통한 탐색 등을 하기에 용이
    - 하지만, 정렬을 위한 연산이 추가적으로 필요함
- LinkedHashMap
    - 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조
    - 배욜, 리스트처럼 인덱싱 접근을 하기에 용이

## 셋(Set)

> 집합을 정의하는 자료 구조
> 
- 집합의 모든 원소는 중복이 허용되지 않음
- 삽입, 삭제, 탐색의 세 가지 연산 지원
- 구현 방식에 따라 HashSet, TreeSet 등이 존재
- 순서를 유지하지 않는다

# 참고 자료

https://velog.io/@kwontae1313/%ED%8A%B8%EB%A6%AC%EC%99%80-%EA%B7%B8%EB%9E%98%ED%94%84%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90

https://sjh9708.tistory.com/221

https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html

https://adjh54.tistory.com/325

https://adjh54.tistory.com/324

https://adjh54.tistory.com/320

https://mangkyu.tistory.com/102

https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html

https://comdon-ai.tistory.com/182

https://blog-of-gon.tistory.com/187

https://jina-developer.tistory.com/101
