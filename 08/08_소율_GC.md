- C언어는 free()로 메모리를 해제해주어야한다.

- 자바는 개발자가 메모리를 직접 해제하지 않는다. 
- GC가 주기적으로 검사하여 불필요한 메모리를 알아서 정리해주기 때문이다. 
- 대신 Java에서 불필요한 데이터를 명시적으로 표현하기로 null을 선언한다.

'''
Person person = new Person();
person.setName("Mang");
person = null;//더이상 참조X->가비지

// 가비지 발생
person = new Person();
person.setName("MangKyu");
'''

System.gc()로 호출가능하지만 시스템성능에 매우 큰 영향을 준다.

## MinorGC vs MajorGC

<img width="556" height="341" alt="스크린샷 2025-10-18 오후 4 22 41" src="https://github.com/user-attachments/assets/9ac33775-21a6-4f2d-8e88-689d4a471b4a" />

JVM의 힙 = 대부분 객체는 접근 불가능한 상태가 된다/오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.로 설계됨

⇒객체 대부분 일회성, 메모리에 오래남아있는 경우 드뭄→객체 생존기간에 따라 영역을 나누었고 YOUNG OLD영역이 설계됨(Perm영역은 Java8부터 삭제)

YOUNG: 새롭게 생성된 객체 할당, 대부분 객체가 금방 접근 불가상태가 되어 많은 객체가 이 영역에 생성되었다가 사라짐, 이 영역에 대한 GC 를 MinorGC

OLD: YOUNG에서 접근가능한 상태를 유지하여 살아남은 객체가 복사되는 영역,YOUNG보다 크게 할당되며 영역의 크기가 큰 만큼 가비지 적게 발생(왜지?),이영역에 대한 GC를 MajorGC

OLD가 크게 할당되는 이유는 YOUNG의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰객체들은 OLD에 할당되기 때문

예외적인 상황: old영역 객체가young영역 객체를 참조할때→512bytes덩어리로 되어있는 카드테이블 존재하여 참조할때마다 정보 표시←YOUNG에서 GC실행될때 OLD영역 객체 검사하여 객체를 식별하는 것이 비효율적이니까→카드테이블만 조회하여 GC대상인지 식별
<img width="546" height="328" alt="스크린샷 2025-10-18 오후 4 23 05" src="https://github.com/user-attachments/assets/474292a0-d948-4bdc-bf12-53699404df6a" />

## GC동작방식
1. Stop The World
    1. GC실행위해 JVM이 앱실행 멈추는 작업
    2. GC를 실행시키는 스레드를 제외한 모든 스레드 작업 중단
    3. GC완료 되면 작업 재개
    4. GC성능 튜닝 = 이 시간을 줄이기 위한 작업
2. Mark and Sweep
    1. Mark: 사용되는 메모리와 아닌 메모리 식별 작업
    2. Sweep: 사용되지 않는 메모리 해제

GC는 스택의 모든 변수 또는 접근가능한 객체를 스캔하면서 각각 어떤 객체를 참조하고있는지 탐색

### MinorGC
Young = Eden1개+Survivor2개

Eden=새로 생성된 객체가 할당되는 영역

Survivor= 최소 1번의 GC이상 살아남은 객체가 존재하는 영역

Eden이 꽉차면 MinorGC발생→사용하지 않는 메모리 해제, 메모리 사용하는 객체는 Survivor로 옮김

1. 새로생성된 객체가 Eden에 할당
2. 객체가 계속 생성되어 Eden꽉참→MinorGC실행
3. Eden에서 사용하지 않는 객체 메모리해제
4. Eden에서 살아남은 객체는 1개의Survivor영역으로 이동
5. 위를 반복하다가 Survivor영역 가득차면 Survivor의 살아남은 객체를 다른 Survivor로 이동→1개의 Survivor영역은 반드시 빈상태
6. 이를 반복하여 계속 살아남으면 Old영역으로 이동

생존횟수 카운트 = age를 Object Heder에 기록→Minor GC가 age를 보고 Promotion여부 결정

Survivor중 1개는 반드시 사용. 모두 데이터 존재하거나 모두 사용량0이면 정상시스템x

<img width="576" height="202" alt="스크린샷 2025-10-18 오후 4 23 49" src="https://github.com/user-attachments/assets/d92282fa-86fe-4d65-93b9-d6d88ef35791" />

Hotspot JVM에서 Eden영역에 객체를 빠르게 할당하기 위해 다음 기술 사용

1. Bump the pointer: Eden영역에 마지막으로 할당된 객체주소 캐싱→새로운 객체를 다음 주소로 사용하게 함으로서 속도 업→객체크기가 Eden영역에 적합한지 판별만 하면 되어 빠르게 메모리 할당
2. TLABs: 멀티스레드 환경에서 락을 걸어 동기화하여 객체를 할당→각 스레드마다 eden영역에 객체를 할당하기 위한 주소를 부여해서동기화 작업 없이 빠르게 메모리할당하도록 하는 기술

### MajorGC
객체들로 Old영역 메모리가 부족해지면 발생→영역이 크기 떄문에 더 오랜시간이 걸리며minorGC보다 10배 이상의 시간 사용

young과 old모두 처리하는 gc는 full gc

## GC알고리즘
Stop the world의해 애플리케이션이 중지되는 것 막기위한 알고리즘

1. Serial GC

Young: Mark Sweep / Old:Mark Sweep Compact 알고리즘 사용(Compact = 힙 영역을 정리하기 위한 단계, 유요한 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워 객체가 존재하는 부분과 객체가 존재하지 않는 부분으로 나누는 것)

서버의 CPU코어가 1개일때 사용하기 위해 개발, 모든 GC는 컬렉션일을 처리하기 위해 1개의 스레드만을 이용

CPU코어가 여러개인 운영 서버에서 SerialGC를 사용하는건 피하기

2. Parallel GC

ThroughputGC임. SerialGC와 처리과정은 동일하지만 여러 스레드를 통해 Parallel하게 GC를 수행함으로서 GC오버헤드를 줄여줌.

멀티프로세서 혹은 멀티 스레드 머신에서 중간 규모부터 대규모 데이터를 처리하는 애플리케이션을 위해 고안. 옵션으로 최대 지연시간, GC를 수행할 스레드 개수 등 설정 가능

Java8까지 기본 GC였다. 하지만 앱이 멈추는것은 피할수없었음.

3. Parallel Old GC

앞서 설명한 Old영역의 GC알고리즘만 다름. Mark Summary Compaction. Symmary단계에서 앞서 GC를 수행한 영역에 대해 별도로 살아있는 객체 식별, 복잡

4. CMS GC

여러 스레드 이용. Mark Sweep Concurrent수행. 앱의 지연시간을 최소화하기 위해 고안.

앱이 구동중일때 프로세서 자원을 공유하여 이용가능해야함. 

해당GC가 수행될때 자원이 GC를 위해서도 사용되니 응답이 느릴순있어도 응답이 멈추지는 않게됨.

→다른 방식보다 메모리와 CPU많이 필요. Compaction수행안하는 단점 존재.

→장기적으로 운영되다 조각난 메모리가 많아 Compaction이 수행되면 Stop the world시간이 길어지는 문제 발생

→Java14부터 중지

<img width="571" height="325" alt="스크린샷 2025-10-18 오후 4 25 28" src="https://github.com/user-attachments/assets/72a6638f-e0c5-4839-a1de-ab87f9503340" />

5. G1 GC

CMS GC대체. 

Java7부터 지원.

기존 GC는 힙영역을 물리적으로 young,old로 나눠사용. 

G1 GC는 Eden에 할당하고 Survivor로 카피하는 과정을 사용하지만 물리적으로 메모리 공간 나누지 않음. 

대신 지역개념을 도입하여 힙을 균등하게 여러 지역으로 나누고 각 지역을 역할과 논리적으로 구분하여 객체 할당

<img width="540" height="537" alt="스크린샷 2025-10-18 오후 4 28 06" src="https://github.com/user-attachments/assets/85b43411-20c9-4ed5-b616-b96ef0cf0116" />

humongous: 지역 크기를 50%초과하는 객체 저장 지역

Available/Unused: 사용되지 않는 지역

핵심은 힙을 동일한 크기의 지역으로 나누고 가비지가 많은 지역에 대해 우선적으로 GC수행. 
G1GC도 다른 가비지 컬렉션과 마찬가지로 Minor Major GC로 나누어 수행.

### MinorGC
한 지역에 객체 할당하다가 해당 지역 꽉차면 다른 지역에 객체 할당.각 지역을 추적하고 있기 때문에 가비지가 가장 많은 지역을 Mark and Sweep

Eden지역에서 GC가 수행되면 살아남은 객체를 식별하고 메모리 회수. 살아남은 객체를 다른 지역으로 이동.

복제되는 지역이 Available/Unused면 해당 지역은 이제 Survivor이 되고 eden영역이 Available/Unused지역으로 됨

### MajorGC
체가 너무 많아 빠르게 메모리를 회수할수없을 때 실행.

기존 GC알고리즘은 모두 힙영역에서 수행→처리시간 상당히 오래걸림.

G1 GC는 어느 영역에 가비지가 많은지 알아서 GC수행할 지역을 조합하여 해당 지역에 대해서만 수행. Concurrent하게 수행되어 앱 지연도 최소화

# 참고자료
[망나니개발자 ](https://www.notion.so/CS-Book-207f065c355f80318fd4f829daa8ce11?source=copy_link#28ef065c355f80ed8e84f7463215dfd0)
https://www.notion.so/CS-Book-207f065c355f80318fd4f829daa8ce11?source=copy_link#28ef065c355f80b8a816dc21802fda53
