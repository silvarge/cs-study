# Garbage Collection(가비지 컬렉션)

> 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거 하는 프로세스
> 
> 
> 자바의 메모리 관리 방법 중 하나
> 
- JVM의 Heap 영역(in Runtime Data Area)에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체를 모아 주기적으로 제거하는 프로세스
- JVM의 가비지 컬렉터가 불필요한 메모리를 알아서 정리해주기 때문에 개발자가 메모리를 직접 해제해 주는 일이 거의 없다.
    - C 언어의 경우, free()라는 함수를 통해 직접 메모리를 해제해 주어야만 함.
    - Java 에서도 System.gc()를 이용해 호출이야 할 수는 있지만, 시스템 성능에 매우 큰 영향을 주니 호출하지 않도록 하자.
- 개발자 입장에서 메모리 관리, 메모리 누수 문제에 대해 크게 신경쓰지 않아도 되어서 개발에만 집중할 수 있다는 장점이 있다.

```java
Person p = new Person();
p.setName("MyName");
p = null;
// 가비지 발생
p = new Person();
p.setName("Gaeko");
```

#### 🗑️ Garbage (가비지)

- 유효하지 않은 메모리
- 더 이상 참조를 하지 않고, 사용이 되지 않는 메모리

👉 Java, Python, Javascript 등의 언어들은 이러한 GC를 염두에 두고 설계되어 언어 자체에 해당 기능이 포함되어 있다.

👉 C, C++ 등의 수동 메모리 관리를 가정하고 설계된 언어의 경우, GC를 지원하는 구현 또한 존재한다는 점!

## GC의 필요성

전통적인 시스템에서는 프로그래머가 메모리를 직접 할당하고 해제했는데, 이는 아래와 같은 문제를 유발할 수 있다.

- 메모리 누수(Memory Leaks): 할당한 메모리를 해제하지 않으면 사용 가능한 메모리가 줄어들고, 이는 시스템이 비정상적으로 종료될 수 있다. (OOM 발생)
- 댕글링 포인터(Dangling Pointers): 아직 사용 중인 메모리를 조기에 해제하면 해당 메모리를 참조할 때 예기치 않는 동작이나 오류가 발생할 수 있다.
- 중복 해제(Double Freeing): 이미 해제한 메모리를 또 해제하게 되면 메모리 구조가 손상되어 프로그램의 오작동을 야기할 수 있다.

이러한 문제를 해결하기 위해 자동 가비지 컬렉션이 도입되었다.

개발자가 메모리를 할당만 하면 되고, 해제 시점은 가비지 컬렉터가 객체의 `도달 가능성(reachability)` 를 기준으로 판단하여 처리한다.

## 특징

### 장점

- 알아서 메모리 관리, 메모리 누수 문제에 대해 처리해 주니까, 개발자가 크게 신경 쓰지 않아도 되어 개발에만 집중할 수 있다는 점 (소듕🥰)

### 단점

- 개발자가 메모리가 언제 해제되는지 그 시점을 정확하게 알 수 없다.
    - 자동으로 처리해준다는 말은 가비지들이 언제, 어떻게 해제되는지 개발자가 알지 못한다는 의미이다.
- 가비지 컬렉션이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생한다 (`Stop-the-World`)
    - 이로 인해 GC가 너무 자주 실행되면 소프트웨어 성능 하락의 문제가 되기도 한다.
    - 실시간으로 계속 동작해주어야 하는 시스템들은 GC의 사용이 적합하지 않을 수 있다. (`STW(Stop The World)` 때문에)
 
# 가비지 컬렉션의 대상

<img width="611" height="434" alt="image" src="https://github.com/user-attachments/assets/b50e352b-d798-440a-bd5c-be075815118e" />

위 사진과 같이, 힙 메모리에 존재하는 인스턴스가 더 이상 참조되지 않는다면, 즉 사용되지 않는다면,
가비지 컬렉터가 주기적으로 힙을 점검하여 `가비지`를 찾아내서 정리한다.

마치, 환경 미화원이 쓰레기를 처리하러 동네를 돌고 있을 때, 쓰레기가 발견되면 말벌 아저씨🏃처럼 달려와 쓰레기를 치우는 것과 같다.

# Heap 메모리와 Garbage Collection
> 이러한 가비지 컬렉션이 주로 작동하는 힙 메모리는 어떻게 생겼을까?
>
<img width="931" height="228" alt="image" src="https://github.com/user-attachments/assets/50205cc4-520e-4407-88b6-1dbc6fb54fab" />

## Young Generation

> 새로 생성된 객체가 저장되며, 정말 갓 생성된 객체가 저장되는 Eden과 두 개의 Survivor 공간으로 나뉨
> 
- 새롭게 생성된 객체가 할당되는 영역
- 대부분의 객체가 금방 접근 불가능한 상태가 되기에 많은 객체가 이 영역에 생성되었다가 사라진다.

## Old Generation

> 여러 GC 사이클에서 살아남은 객체가 이 곳으로 이동하게 됨
> 
- Young Generation에서 살아남은 객체가 가는 곳
- 일반적으로 Young Generation보다 크게 할당하여 크기가 크다.
    - 그만큼 GC가 적게 발생

## Metaspace (Java 8 이전 - Permanent Generation)

> 클래스와 메소드의 메타데이터들이 저장되는 공간 (이제는 Native Memory 영역에 존재)
>

# Minor GC와 Major GC

JVM의 Heap 영역은 아래와 같은 내용을 전제로 설계되었다.
(`weak generational hypthesis` 가설)

- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

⇒ 객체는 대부분 일회성이며, 메모리에 오래 남아있는 경우는 거의 없다는 것!

## Minor GC

> Young Generation에 대한 가비지 컬렉션
> 

Young Generation은 Eden 영역(갓 태어난 객체)과 두 개의 Survivor 영역(그래도 좀 생존한 객체)으로 구성된다.

### 동작 방식

- Eden 영역이 가득 찰 때
    - 새로운 객체가 주로 Eden 영역에 할당된다.
    - 만약, Eden 영역이 가득 차면 Minor GC가 발생한다.
- 생존 객체 이동
    - Minor GC 동안, Eden 영역의 모든 객체가 검사된다. 살아남은 객체는 Survivor 영역으로 이동한다. (두 Survivor 영역 중 하나로 이동)
    - 하나의 Survivor 영역이 가득 차면 다른 Survivor 영역으로 객체가 이동된다.
    - 여러 번의 Minor GC를 통해 Survivor 영역에 남아 있는 객체가 Old Generation으로 승격된다.
    (쓸모 없는 객체 청소를 여러 번 거쳐서도 살아남았다는 것
    = 오랜 기간동안 생존한 객체로 있었다는 것)
- 빠른 수행 시간
    - Minor GC는 상대적으로 빠르게 수행된다.
    - Young Generation은 크기가 작기 때문에 컬렉션 작업이 빠르게 완료된다.
    - 하지만 이 상황에서도 STW는 일어난다. (Major GC보다는 아니지만)

### 영향

Minor GC는 Young Generation의 객체를 정리하는 과정으로, 응답 시간에 짧은 영향을 미칠 수 있다.

그러나, 이 영향은 대부분의 경우 비교적 적다.

## Major GC (Full GC)

> Old Generation에 대한 가비지 컬렉션
> 

### 동작 방식

- Old Generation이 가득 찰 때 발생
    - Old Generation의 메모리가 부족할 때(가득 차 있을 때) Major GC가 발생
- 전체 힙 검사
    - Major GC는 Young Generation 뿐만 아니라 Old Generation 전체를 검사한다.
    - 이 과정에서 모든 살아있는 객체를 식별하고 가비지를 정리하게 된다.
- 상대적으로 긴 수행 시간
    - Major GC는 전체 힙을 검사하므로 시간이 더 오래 걸린다.
    - 이로 인해 애플리케이션의 일시적인 중단(STW)이 발생할 수 있다.

### 영향

- Major GC는 애플리케이션 성능에 더 큰 영향을 미칠 수 있다.
- 특히, Old Generation의 크기와 객체 수가 많을수록 GC 수행 시간이 길어질 수 있다. (큰 만큼 검사해야 할 것도 많기 때문)
- Major GC가 자주 발생하면 성능 저하를 유발할 수 있으므로, 메모리 관리와 GC 튜닝이 중요하다.

# GC 기법 (GC 알고리즘)

> GC는 주기적으로 힙을 점검하여, “가비지”를 찾아 메모리를 해제하는 역할을 수행한다.
그렇다면, GC는 어떤 방법으로 청소(메모리 해제)를 진행할까?
> 

### GC 알고리즘의 주요 고민

- 어떻게 불필요한 인스턴스(객체)인지 알 수 있을까?
- GC가 동작하는 동안 프로그램이 중단되는 시간을 어떻게 줄일 수 있을까?

## 도달 가능성(reachability)

> `Root Object`로부터 접근 가능한 객체인가?
> 

루트 객체에서부터 해당 객체에 `도달 가능성(reachability)` 여부를 메모리 해제의 기준으로 삼는다.

만약, 이러한 연쇄 참조 과정에서 탐지되지 않는 객체가 있다면, 해당 객체는 더 이상 접근 불가능 한 것으로 판단되며, 따라서 GC의 대상이 된다.

이러한 Root Set은 아래 세 가지 형태로 나뉜다. 이 조건에 부합하는 객체들이 Root가 되는 것

- JVM Stack 내의 Local Variable Section과 Operand Stack 에서의 참조
→ Java 메서드 내에서 실행하는 지역 변수 또는 파라미터에 의한 참조
- JVM Method Area의 Constant Pool에서의 참조
→ 정적 변수에 의한 참조
- 아직 메모리에 남아 있는 Native Method로 넘겨진 Object에서의 참조
→ JNI에 의해 생성된 객체에 대한 참조

이로부터 이어진 참조 사슬에 포함되어 있다면 도달 가능한 객체이고
아니면 도달 불가능한 객체이기에 Garbage로 간주하여 GC의 대상이 되는 것이다.

## GC의 기본 알고리즘

### Reference Counting (참조 카운팅)

> 각 객체에 있는 Reference Count(참조 카운트)를 관리하여 Reference Count가 0이 되면 GC를 수행한다.
> 

<img width="1520" height="351" alt="image" src="https://github.com/user-attachments/assets/a5c16bb4-e31a-435d-b074-65c0f9d51ec3" />

- 각 객체마다 Reference Count를 변경해 주어야 하기 때문에 그에 대한 관리 비용이 크다
- 참조를 많이 하고 있는 객체의 Reference Count가 0이 되는 경우, 연쇄적으로 GC가 발생할 수 있는 문제가 있다.

<img width="898" height="524" alt="image" src="https://github.com/user-attachments/assets/3700a9d0-222c-4631-884f-c938ef175923" />

- 순환 참조 구조에서 메모리 누수가 발생할 가능성이 있다.
(서로가 서로를 참조하니 Count가 0이 되지 않아 GC의 대상이 되지 않는 것)

### Mark-and-Sweep Algorithm

> Mark(표시)하고 Sweep(청소)하는 알고리즘
> 

<img width="1170" height="691" alt="image" src="https://github.com/user-attachments/assets/9771a274-f94c-428f-a8f3-223893c8c50b" />

Reference Counting 알고리즘의 단점을 극복하기 위해 나온 알고리즘

이 방식에서 Root Set에서 시작하는 Reference 관계를 추적. 그래서 Tracing Algorithm이라고도 한다.

각각의 객체는 1비트의 flag를 하나씩 갖는다.

1. Mark 단계: 객체 참조 그래프의 Root로부터 도달할 수 있는 객체를 전부 마킹
(살아남아야 할 객체에 표시)
2. Sweep 단계: 마킹되지 않은 객체를 메모리에서 해제

간단한 방식으로 동작하지만, STW(stop the world) 시간이 길고, Sweep 과정 후 메모리가 해제됨에 따라 단편화가 발생할 수 있는 단점이 존재한다.

### Mark-and-Compact Algorithm

> Mark-and-Sweep의 ‘단편화’라는 약점을 극복하기 위해 나온 알고리즘
> 

<img width="1170" height="564" alt="image" src="https://github.com/user-attachments/assets/92500b10-e2a8-4c8c-9cfd-66c5cafe568c" />

Mark-and-Sweep 과정에 추가적으로 Compact 과정을 거치는 것.

Sweep 과정까지 진행한 후, 회수된 객체들이 차지하고 있던 파편화 된 메모리 조각들을 하나로 모으기 위해 생존한 객체들을 한 곳으로 이동시킨다. 따라서 이런 Compact 과정을 거치면 메모리 공간의 효율을 높일 수 있다.

하지만, Compaction 작업 이후 살아남은 모든 객체들의 Reference를 업데이트 하는 작업이 필요하기에 부가적인 오버헤드가 발생한다.

### Copying Algorithm

> 단편화 문제를 해결하기 위해 제시된 또 다른 알고리즘
> 

<img width="1296" height="1081" alt="image" src="https://github.com/user-attachments/assets/787dc9c1-88f5-4a26-b43f-f8494aaf2f48" />

현대의 GC가 채택하고 있는 Generation Algorithm이 이 Copying Algorithm을 발전시킨 형태.

Copying Algorithm의 기본 아이디어는 힙을 Active 영역과 InActive 영역으로 나누어, Active 영역에만 객체를 할당할 수 있도록 하고, Active 영역이 꽉 차게 되면 GC를 수행한다는 것.

GC를 수행하면 중단 상태가 되고, 살아남은 객체를 InActive 영역으로 복사(Copy)한다. Copy 하는 동안 프로그램이 Suspend(중단) 상태가 되기 때문에 Stop-and-Copy이라고도 부른다.

Copy 작업을 완료하면 Active 영역에는 Garbage Object만 남게 되고, InActive 영역에는 Live Object만 남게 된다. 이후 Garbage Object를 제거하게 되면 Active 영역은 Free Memory 상태가 되고, Active 영역과 InActive 영역이 서로 바뀌게 된다(`Scavenge`). 
→ Active 영역과 InActive 영역은 논리적인 구분 (단순히 힙 영역을 반으로 나누어 객체를 할당한다고 보면 됨)

단편화 문제를 해결하기 위해 Copy하는 과정에서 각 객체들의 Reference를 업데이트 하면서 적재시킨다.

하지만 이 친구들은 전체 힙의 절반밖에 사용하지 못한다는 공간 활용의 비효율성, 중단 현상, Copy에 대한 오버헤드가 존재한다는 단점이 있다.

### Generaiton Algorithm

> weak generational hypthesis를 바탕으로 고안된 알고리즘
> 

<img width="1265" height="663" alt="image" src="https://github.com/user-attachments/assets/443b32f8-b478-4b0f-8eda-c7f657c65d04" />

#### 📝 weak generational hypthesis

- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

Young Generation과 Old Generation, 이 두 개의 Sub Heap으로 나뉘어 존재한다.

GC가 수행될 때마다 살아남은 객체에 Age를 기록한다. HotSpot JVM에서는 Age 임곗값의 기본 값은 31이다. (age를 기록하는 부분이 6비트로 되어있기 때문, 몇 번 살아남았는지 정도를 표시)

이 age가 특정 임계값을 넘어서면 Old Generation으로 Copy하는 작업을 수행한다(`Promotion`).

대부분의 객체는 Young Generation에 살다가 Garbage가 되기 때문에 Copy 작업의 횟수를 최소화 시킬 수 있다. 또한, Old Generation으로 Copy함과 동시에 Compation 작업이 이루어진다.

주로 사용하고 있는 HotSpot JVM이 Generation Algorithm을 바탕으로 Heap 메모리를 구성하고 있다.

<img width="1280" height="639" alt="image" src="https://github.com/user-attachments/assets/22ed695c-6bb3-4769-a082-88d8fa6ed801" />
Java 8 이상 기준

# Garbage Collector의 종류

JVM 버전이 올라감에 따라 여러 GC 방식이 추가되고 발전되어 왔다.

JVM 버전이 많이 올라간 만큼, 다양한 GC 방식이 존재하며, 상황에 따라 필요한 GC 방식을 설정해서 사용할 수 있다.

## Serial GC

> `-XX:+UseSerialGC`
> 

Serial 이란 단어의 의미인 `순차적인` GC 방식.

싱글 스레드를 활용하여 GC 작업을 수행한다. 이 방법은 스레드 사이의 커뮤니케이션 오버헤드가 없으므로 상대적으로 효율적이다.

하지만, 멀티 프로세서 하드웨어의 장점을 살릴 수 없기에 적은 메모리와 싱글 프로세스 머신 환경에 적합한 방식이다. (메모리나 CPU Core 리소스가 부족할 때 사용할 수 있을 것)

## Parallel GC (Throughput GC)

> `-XX:+UseParallelGC`, `-XX:ParallelGCThreads (Minor GC 스레드 개수)`
> 

Minor GC를 처리하는 스레드를 여러 개로 늘려 좀 더 빠른 동작이 가능하게 한 방식

Minor GC를 병렬로 수행하므로 오버헤드를 현저히 줄일 수 있다.

메모리가 충분하고 프로세서의 개수가 많을 수록 유리

## Parallel Old GC

> `-XX:+UseParallelOldGC`, `-XX:ParallelGCThreads (Minor, Full GC 스레드 개수)`
> 

Parallel GC를 조금 더 업그레이드 한 버전, Parallel GC에서 Old GC 알고리즘을 개선.

Old GC도 병렬로 수행될 수 있도록 한다(멀티 스레드)

또한, Serial GC, Parallel GC의 알고리즘은 Mark-Sweep-Compaction이었으며,
Parallel Old GC에서는 개선된 버전인 Mark-Summary-Compaction 알고리즘을 사용한다.

→ Summary 단계에서는 이미 GC가 수행된 영역에서 살아있는 객체를 식별하는 작업을 진행한다는 점이 Sweep과 다르다. 이는 Old GC의 처리량을 늘려 주기 위한 작업

## Concurrent Mark Sweep(CMS) Collector

> `-XX:+UseConcMarkSweepGC`
> 

CMS는 GC 과정에서 발생하는 STW(Stop-The-World) 시간을 최소화하는 데 초점을 맞춘 GC 방식.

앞선 GC들보다 개선된 방식어서 성능은 좋아졌지만, GC의 과정은 조금 더 복잡해졌다.

GC 대상을 최대한 자세히 파악한 후, 정리하는 시간(STW 시간)을 짧게 가져가겠다는 컨셉.
하지만, GC 대상을 파악하는 과정이 복잡한 여러 단계로 수행되기에 다른 GC 대비 CPU 사용량이 높다.

- CMS GC 과정
    
    > Initial Mark → Concurrent Mark → Remark → Concurrnet Sweep
    > 
    1. Initial Mark: GC Root에서 참조 트리 상 가까운 객체만 일차적으로 찾아가서 GC 대상인지 판단
    (STW가 발생하지만, 탐색 깊이가 얕아 발생 기간이 매우 짧다)
    2. Concurrent Mark: Initial Mark 단계에서 GC 대상으로 판별된 객체들이 참조하는 다른 객체들을 따라가며 GC 대상인지 추가적으로 확인
    (STW 현상 없이 진행됨)
    3. Remark: Concurrent Mark 단계의 결과를 검증. 앞선 단계에서 GC 대상으로 추가 확인되거나 참조가 제거되었는지 등의 확인을 진행
    (STW 유발, STW 시간을 최대한 줄이기 위해 멀티 스레드로 검증 작업 수행)
    4. Concurrent Sweep: Remark 단계에서 검증 완료된 GC 객체들을 메모리에서 제거
    (STW 없음)

CMS GC는 Compaction 작업을 필요한 경우에만 수행한다.
연속적인 메모리 할당이 어려울 정도로 메모리 단편화가 심한 경우에만 Compaction 과정을 수행

## G1 GC (G1: Garbage First)

> `-XX:+UseG1GC`, `-XX:G1HeapRegionSize`
> 

<img width="785" height="783" alt="image" src="https://github.com/user-attachments/assets/e1c1017a-7819-4f15-a284-80330428cd56" />

큰 힙 메모리에서 짧은 GC 시간을 보장하는 데 그 목적을 둔다.

전체 힙 메모리 영역을 Region이라는 특정한 크기로 나눠, 각 Region 상태에 따라 그 Region에 역할 (Eden, Survivor, Old)이 동적으로 부여되는 상태

JVM 힙은 2048개의 Region으로 나뉠 수 있으며, 각 Region의 크기는 1MB-32MB 사이로 지정될 수 있다.
(`-XX:G1HeapRegionSize`로 설정)

- 특징
    - 큰 메모리를 가진 멀티 프로세서 시스템에서 사용되기 위해 개발된 GC
    - CMS 보다 훨씬 튜닝하기 쉽다
    - 조기 승격에 덜 취약하다 (조기 승격: 할당률이 높아서 Old 영역으로 너무 빨리 승격되는 것)
    - 대용량 힙에서 확장성(특히, 중단 서버)이 우수
    - 자바 9부터는 Default GC로 G1GC를 사용한다.
    - 우리가 봐왔던 Heap 영역에서 보지 못한 Humongous, Available/Unused 가 존재한다
        - Humongous: Region 크기의 50%를 초과하는 큰 객체를 저장하기 위한 공간, 이 Region에서는 GC 동작이 최적으로 동작하지 않는다.
        - Available/Unused: 아직 사용되지 않은 Region을 의미

G1 수집기는 RSet(Remembered Set)을 통해 어떤 객체가 어떤 리전에 저장되어 있는지 추적한다. 덕분에 G1은 영역 내부를 바라보는 레퍼런스를 찾으려고 전체 힙을 다 뒤질 필요 없이 RSet만 꺼내 보면 된다.

### G1의 수집 단계

- Young GC [`STW`]
    - 각 Region 중 GC 대상 객체가 가장 많은 Region(Eden 또는 Survivor 역할)에서 수행되며,
    - 이 Region에서 살아남은 객체를 다른 Region(Survivor 역할)으로 옮긴 후,
    - 비워진 Region을 사용 가능한 Region으로 돌리는 형태로 동작
- Full GC (Initial Mark → Root Region Scan → Concurrent Mark → Remark → Cleanup → Copy)
    1. Initial Mark [`STW`]: Old 영역에 존재하는 객체들이 참조하는 Survivor 영역을 찾는다.
    2. Root Region Scan: Initial Mark 단계에서 식별한 Survivor 영역에서 Old 영역을 가리키는 레퍼런스를 식별한다.
    3. Concurrent Mark: 힙 전체에 걸쳐 접근 가능한 살아 있는 객체를 찾는다.
    4. Remark [`STW`]: Concurrent Mark 단계를 검증하고, 최종적으로 살아남을 객체들을 식별한다. 이 단계에서는 SATB(Snapshot-At-The-Beginning) 알고리즘이 사용된다.
    5. Cleanup  [`STW`]: 애플리케이션을 멈추고(STW) 살아 있는 객체가 가장 적은 리전에 대한 미사용 객체를 제거한다. 이후 STW를 끝내고 앞선 GC 과정에서 완전히 비워진 리전을 FreeList에 추가하여 재사용 할 수 있게 한다.
    6. Copy: GC 대상 리전이었지만, Cleanup  과정에서 완전히 비워지지 않은 리전의 살아남은 객체들을 새로운 리전에 복사하여 Compaction 작업을 수행한다.

## ZGC (Z Garbage Collector)

> `-XX:+UseZGC`, `-XX:+UnlockExperimentalVMOptions`
> 

<img width="900" height="572" alt="image" src="https://github.com/user-attachments/assets/a8be1834-a6f6-45ae-a028-ce9113f7083b" />
https://www.packtpub.com/en-us/learning/how-to-tutorials/getting-started-with-z-garbage-collectorzgc-in-java-11-tutorial/?ref=blog.pollra.com

대규모 애플리케이션에서 낮은 지연 시간과 높은 처리량을 목표로 설계됨
(대용량 메모리 환경에서 지연 시간이 중요한 경우)

Java 11에 처음 도입되어, Java 15에서 안정되었다고 한다. (하지만 Java 15에서도 기본은 G1GC)

- 특징
    - 기본적으로 Mark & Sweep 알고리즘을 사용한다
    - 메모리를 ZPage라는 논리적인 단위로 구분한다.
        - 메모리 영역을 동적으로 생성/삭제하며 부여
        - ZPage는 2MB 배수 형태로 관리하여 위 사진과 같이, Small, Medium, Large로 분류한다.
    - 저지연: 가비지 컬렉션으로 인한 지연 시간을 매우 짧게 유지
    (일반적으로 수 밀리초 이내로 유지)
    - 대규모 힙 지원: 테라바이트 단위의 대규모 힙 메모리까지 지원
    - 컴팩션 지원: 메모리 파편화 방지를 위해, 메모리 컴팩션 지원
    (메모리를 재배치하여 더 큰 연속된 메모리 블록을 확보할 수 있도록 함)
    - Concurrent Processing: 대부분의 가비지 컬렉션 작업을 애플리케이션 스레드와 동시에 수행
    - Colored Pointers: colored pointers라는 기법을 사용하여 객체의 상태를 관리
        - 포인터에 색상을 추가하는 기법 (64비트 주소 공간 중 일부 비트를 사용하여 표현)
        - 객체가 마킹되었는지, 이동 중인지 등의 상태를 나타내는 데 사용

### ZGC의 수집 단계

1. 마킹 (Marking)
    1. 초기 마킹 (Initial Mark): 애플리케이션 스레드가 실행되는 동안 루트 객체들을 마킹
    2. 동시 마킹 (Concurrent Mark): 애플리케이션 스레드와 병렬로 힙 전체를 스캔하여 객체 마킹
    3. 재마킹 (Remark): 최종 마킹 단계, Concurrent Mark 단계 이후에 변경된 객체들을 다시 마킹
2. 이동 (Relocation)
    1. 동시 이동 (Concurrent Relocate): 애플리케이션 스레드와 병렬로 살아 있는 객체들을 새로운 메모리 영역으로 이동
3. 정리 (Clean up): 사용되지 않는 메모리 블록을 회수하여 새로운 객체가 할당될 수 있도록 함

### G1GC와 ZGC의 차이점

| 구분 |  G1GC | ZGC |
| --- | --- | --- |
| 지연 시간 | 사용자 정의 가능한 지연 시간 목표(기본 200ms), 일반적으로 ZGC보다 길 수 있다 | 매우 낮은 지연 시간<br>(10ms 이하 pause time 보장) |
| 힙 구조 | 고정 크기의 Region(1-32MB) | 페이지 기반 구조 (ZPage) |
| 가비지 컬렉션 방식 | 일부 동시 작업과 함께 Young 및 Mixed Collection 수행 | 대부분의 작업이 애플리케이션 스레드와 동시에 수행 |
| 대규모 힙 지원 | 작은 힙에서도 잘 동작하지만, 대규모 힙에서도 사용 가능 | 테라바이트 단위의 대규모 힙 지원 |
| 메모리 파편화 방지 | Region Evacuation을 통해 방지 | Colored Pointers와 동시 재배치를 통해 효율적으로 방지 |
| CPU 오버헤드 | 상대적으로 낮은 CPU 사용량 | 낮은 지연 시간을 위해 더 높은 CPU 사용량 (약 15%) |
| JDK 버전 적용 | JDK 9부터 기본 GC로 사용 | JDK 11부터 실험적 사용 가능, JDK 15부터 안정화 |
| 적용 대상 | 지연 시간과 처리량 간의 균형이 필요한 애플리케이션 (무난) | 낮은 지연 시간이 중요한 대규모 애플리케이션 |

# 내 Java에서는 뭘 사용하고 있을까?

> 갑자기 궁금해져서 실행해 보았다.
> 

```java
java -XX:+PrintCommandLineFlags -version
```
JVM이 실행될 때 내부적으로 어떤 기본 -XX 플래그를 설정해서 사용하는 지 보여줌

```java
:ConcGCThreads=5 -XX:G1ConcRefinementThreads=18 -XX:InitialHeapSize=521821888 
-XX:MarkStackSize=4194304 -XX:MaxHeapSize=8349150208 -XX:MinHeapSize=6815736 
-XX:+PrintCommandLineFlags -XX:ReservedCodeCacheSize=251658240 -XX:+SegmentedCodeCache 
-XX:+UseCompressedOops ***-XX:+UseG1GC*** -XX:-UseLargePagesIndividualAllocation
java version "23" 2024-09-17
Java(TM) SE Runtime Environment (build 23+37-2369)
Java HotSpot(TM) 64-Bit Server VM (build 23+37-2369, mixed mode, sharing)
```

G1GC를 사용하는 것을 볼 수 있다!

# 참고 자료


https://mangkyu.tistory.com/118

https://mangkyu.tistory.com/119

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

https://s-y-130.tistory.com/111

https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html

https://junhyunny.github.io/information/javascript/mark-and-sweep-gc-in-javascript/

https://junhyunny.github.io/information/javascript/reference-counting-gc-in-javascript/

https://blog.siner.io/2021/12/26/garbage-collection/

https://csg1353.tistory.com/279

https://medium.com/@AlexanderObregon/understanding-javas-garbage-collection-bc141a2ef31f

https://d2.naver.com/helloworld/1329

https://mirinae312.github.io/develop/2018/06/04/jvm_gc.html

https://jangjjolkit.tistory.com/30

https://digitalbourgeois.tistory.com/234

https://d2.naver.com/helloworld/0128759

https://cafe-de-java.tistory.com/32

https://blog.pollra.com/f-lab-mogacko-day-31/
