# Garbage collection

## 개요

가비지 컬렉션은 힙 영역의 메모리를 관리해주는 기술이다. 더 이상 사용하지 않거나 접근할 수 없는 인스턴스의 메모리를 회수한다.

## 살았는가 죽었는가?

### 알고리즘

가비지 컬렉터가 객체를 회수하기 위해서는 먼저 어떤 객체가 살아있고 죽었는지 판단해야 한다. 기본적인 알고리즘으로 참조 카운팅 알고리즘이 있다.

- 객체를 가리키는 참조 카운터를 추가한다
- 이 객체를 참조하는 곳이 생기면 값을 1 증가시키고, 사라지면 1 감소시킨다
- 0이 되면 객체가 죽었다고 판단한다

하지만 참조 카운팅 알고리즘은 순환 참조 문제를 해결하기 어렵다. 예를 들어 어떤 두 객체를 만든 후에 필드에 서로를 참조하도록 하고 객체의 참조를 해제한다. 이렇게 되면 외부에서 객체에 접근할 수 없지만 서로가 참조하고 있기 때문에 참조 카운터는 0보다 크다.

자바는 객체의 생사 판단에 **도달 가능성 분석 알고리즘**을 이용한다. **GC 루트**라고 하는 객체를 시작 노드 집합으로 사용한다. 시작 노드에서 출발해서 객체가 참조하는 객체들을 탐색한다. 이 때 만들어지는 경로를 **참조 체인**이라고 하고 참조 체인이 이어져 있지 않으면 접근할 수 없는 객체로 판단해서 메모리를 회수한다.

GC 루트로 사용할 수 있는 객체는 다음과 같다.

- 가상 머신 스택에서 참조하는 객체: 현재 실행중인 메서드에서 사용하는 매개 변수, 지역 변수, 임수 변수 등
- 메서드 영역에서 클래스가 정적으로 참조하는 객체: 참조 타입 정적 변수
- 메서드 영역에서 상수로 참조되는 객체: 문자열 테이블 안의 참조
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- JVM 내부에서 사용하는 참조: Class 객체, NPE 등의 일부 상주 예외 객체, 시스템 클래스 로더
- 동기화 락(synchronized)으로 잠겨있는 모든 객체
- 정해진 것 이외의 GC 종류나 현재 회수중인 메모리 영역에 따라 정해진 임시 객체들

### 참조

JDK 1.2 이전의 자바는 참조를 다음과 같은 의미로 정의했다

> 참조 타입 데이터에 저장된 값이 다른 메모리 조작의 시작 주소를 뜻한다면, 이 참조 데이터를 해당 메모리 조각이나 객체를 참조한다고 한다.

맞는 정의지만 참조되거나 참조되지 않은 두가지 상황밖에 표현하지 못한다. 메모리가 여유로우면 그냥 두고, 매우 부족하면 그때 회수하는 등의 애매한 객체를 판단하기 위해 참조의 개념을 확장하여 4가지로 분류했다

- 강한 참조: 전통적인 의미의 참조
  - `Object ojb = new Object()`와 같이 프로그램 코드에서 할당한 참조
  - 강한 참조가 남아있으면 절대 회수하지 않는다
- 부드러운 참조: 유용하지만 필수는 아닌 참조
  - 부드러운 참조만 남아있는 개체는 메모리 오버플로가 나기 직전에 두 번째 회수를 위한 목록에 추가된다
  - 두번째 회수 후에도 메모리가 부족하면 그 때 메모리 오버플로 예외를 던진다
- 약한 참조: 부드러운 참조와 비슷하지만 연결 강도가 더 낮은 참조
  - 다음번 가비지 컬렉션까지만 살아 있다
  - 가비지 컬렉터가 작동하면 메모리가 여유있어도 모두 회수된다
- 유령 참조: 가장 약한 참조
  - 객체 수명에 영향을 주지 않고 이 참조로 인스턴스를 가져오는 것도 불가능하다
  - 대상 객체가 회수될 때 알림을 받기 위해서 존재한다

### 메서드 영역

JVM 명세에 따르면 가비지 컬렉터가 메서드 영역을 반드시 청소해야 하는 것은 아니다. 실제로 메서드 영역 타입 언로딩을 구현하지 않거나 완벽하게 수행하지 않는 가상 머신도 존재한다. 메서드 영역 가비지 컬렉션은 힙 영역에 비해 비용 효율이 좋지 않다. 힙 영역은 한번 회수하면 70~99%를 회수한다. 하지만 메서드 영역은 회수 조건이 까다로워서 훨씬 비효율적이다.

메서드 영역의 가비지 컬렉션은 크게 더 이상 사용하지 않는 상수와 클래스를 회수한다. 

상수를 회수하는 방법은 힙에서 회수하는 것과 비슷하다. 예를 들어 문자열 "java"가 상수 풀에 있지만, 이 문자열을 참조하는 객체가 존재하지 않고 가상 머신에서 이 문자열 리터럴을 사용하는 곳이 하나도 없으면 회수하는 방식이다. 상수 풀에 있는 다른 클래스, 메서드, 필드의 심벌 참조도 유사하게 회수된다

클래스는 상수에 비해 판단이 까다로워 다음 3가지 조건을 만족해야 한다.

- 해당 클래스의 인스턴스가 모두 회수되었다. 힙에 클래스와 하위 클래스의 인스턴스가 존재하지 않는다.
- 해당 클래스를 읽어들은 클래스 로더가 회수되었다. 이 조건은 OSGi, JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
- 해당 클래스의 Class 객체를 아무도 참조하지 않고, 리플렉션으로 이 클래스의 메서드를 이용하는 곳도 없다.

JVM은 쓸모없는 클래스를 회수하는 것을 허용한다. 클래스 회수 여부를 제어할 수 있도록 `-XnoClassgc` 매개 변수를 제공한다. 리플렉션, 동적 프록시, CGLiB와 같은 바이트코드 프레임워크를 많이 사용하는 경우나 OSGi 환경 등에서는 일반적으로 JVM이 타입 언로딩을 지원해야 한다. 그레야 메서드 영역이 가득 차는 것을 막을 수 있다.

## 가비지 컬렉션 알고리즘

가비지 컬렉션에 사용되는 알고리즘은 다음과 같은 가정에 기반하여 설계되었다.

- 약한 세대 가설: 대다수 객체는 일찍 죽는다
- 강한 세대 가설: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 높다
- 세대 간 참조 가설: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다

이를 **세대 단위 컬렉션 이론**이라고 한다. 이 이론을 적용한 가상 머신들은 힙 영역을 최소 2가지 영역, **신세대와 구세대 영역**으로 나눈다. 신세대에서는 가비지 컬렉션 때마다 많은 객체가 회수되고 살아남은 소수만 구세대로 승격된다. 신세대에서 이루어지는 가비지 컬렉션을 마이너 GC, 구세대는 메이저 GC 라고도 한다. 

가설에 따르면 마이너 GC를 수행할 때 구세대 전체를 훑는 것은 낭비다. 그렇기에 단순히 신세대애 기억 집합이라는 전역 데이터 구조를 두어 관리한다. 구세대를 작은 조각 몇개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 기록해 관리한다.

### 마크-스윕

**마크-스윕 알고리즘**은 가장 기본적인 알고리즘이다. 먼저 회수할 객체를 표시하고 표시된 객체들을 전부 회수하는 방법이다.

가장 기본적인 알고리즘이지만 몇가지 단점이 있다.

- 실행 효율이 일정하지 않음: 객체가 많을수록 표시하고 쓸어담는 작업의 효율이 떨어진다.
- 메모리 파편화가 심함: 가비지 컬렉터가 회수하고 간 자리에는 불연속적인 메모리의 파편이 만들어진다.

### 마크-카피

**마크-카피 알고리즘**은 회수할 객체가 많아질수록 효율이 떨어지는 마크-스윕 알고리즘의 단점을 개선한 알고리즘이다. 

이 알고리즘은 가용 메모리를 같은 크기의 2개의 블록으로 나누고 한 번에 한 블록만 사용한다. 한 쪽 블록이 다 차면 살아남은 객체를 다른 블록에 복사하고 기존 블록을 전부 청소한다.

대다수의 객체가 회수되기 때문에 생존한 소수의 객체만 복사하면 돼서 메모리 복사에 큰 시간을 소모하지 않는다. 또한 메모리에 순서대로 복사하기 때문에 파편화 문제도 해결 가능하다. 구현하기 쉽고 실행 효율도 좋지만 가용 메모리를 절반으로 줄여 낭비가 심하다는 것이 단점이다.

이를 해결하고자 메모리 공간을 1대1로 나누는 것이 아닌 하나의 큰 **에덴** 공간과 두개의 작은 **생존자** 공간으로 나눈다. 신세대의 대부분의 객체는 첫번째 가비지 컬렉션에서 살아남지 못하기 때문이다. 에덴 공간과 두개의 생존자 공간을 8:1:1 비율로 나누어 사용한다. 메모리를 할당할 때는 에덴 공간과 생존자 공간 중 하나만 사용한다. GC가 시작되면 살아남은 객체들을 나머지 생존자 공간으로 복사한 후에 에덴과 이전 생존자 공간을 비운다.

### 마크-컴팩트

마크-카피 알고리즘은 객체의 생존율이 높을수록 복사할게 많아져서 구세대에 적합하지 않은 방법이다. 

**마크-컴팩트 알고리즘**은 생존할 객체를 메모리에 한쪽 끝으로 모은 다음에 나머지 공간을 비우는 방식이다. 

마크-스윕 알고리즘과 다른 점은 메모리의 이동이 일어난다는 점이다. 메모리의 이동이 일어나면 메모리 복사 작업은 이동된 객체를 가리키는 참조를 모두 수정해야 한다. 이 과정은 사용자 스레드를 멈춘 상태에서 진행해야 하기 때문에 stop-the-world 시간이 더 길어진다는 단점이 있다.

하지만 객체를 이동시키지 않는다면 힙이 파편화된다는 문제가 여전히 존재한다. 이를 해결하려면 메모리 할당을 파편화 없는 할당 연결 리스트 등으로 해결해야 한다 .이는 읽기 성능에 영향을 미치기 때문에 어플리케이션의 성능이 저하된다. 

결국 각각의 장단점이 있다. 객체를 이동시키면 회수 작업이 복잡해지고, 이동시키지 않으면 할당 작업이 복잡해진다. 가비지 컬렉션 시의 stop-the-world 시간을 줄이기 위해서는 이동시키지 않는 것이 유리하지만, 어플리케이션의 전체 처리량을 늘리기 위해서는 이동시키는 것이 효율적이다. 

핫스팟 가상 머신에서는 처리량에 중점을 둔 패러렐 올드 컬렉터는 마크-컴팩트 알고리즘을 사용하고, 지연 시간에 중점을 둔 CMS 컬렉터는 마크-스윕 알고리즘을 사용한다.

## 가비지 컬렉터 종류

### 시리얼 컬렉터

- 가장 기초적인 컬렉터이며 단일 스레드로 동작한다
- 가비지 컬렉션이 시작되면 작업이 완료될 때까지 모든 작업 스레드가 정지해야 한다
- 가용 메모리가 적은 환경거나 코어 수가 적은 환경에서 적합하다

### 패러렐 컬렉터

- 처리량을 중시하는 컬렉터이다
- 신세대에는 마크-카피, 구세대에는 마크-컴팩트 알고리즘을 사용한다
- 멀티 스레드를 이용하여 병렬로 작업을 진행한다

### G1

- 힙 영역 전체를 리전으로 나누어 관리한다
- 각각의 리전들은 에덴, 생존자, 구세대 중 하나를 부여받는다
- 각 리전의 쓰레기 누적값을 추적하고 허용하는 한도 내에 서 회수 효과가 가장 큰 리전부터 회수한다
- 현재 자바의 기본 가비지 컬렉터이다
