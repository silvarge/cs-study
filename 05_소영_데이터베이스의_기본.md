> 이 포스팅은 주홍철 저 '면접을 위한 CS 전공지식 노트' 4.1장을 토대로 작성되었습니다.

---

## 📌 데이터베이스의 기본

-   데이터베이스(Database, DB)
    -   **일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음**
    -   실시간 접근과 동시 공유가 가능하다.
-   DBMS(DataBase Manangement System)
    -   **데이터베이스를 제어, 관리하는 통합 시스템**
    -   데이터베이스 내 데이터베이들은 DBMS마다 정의된 쿼리 언어를 통해 삽입/삭제/수정/조회가 될 수 있다.
    -   응용 프로그램은 DBMS를 통해 데이터베이스 내 데이터를 사용할 수 있다.
    -   예) MySQL, PostgreSQL

---

### 📌 엔티티

-   사람, 물건, 사건 등 여러 개의 속성을 지닌 명사로, **데이터베이스에서 관리하고 싶은 대상 하나하나**
-   속성은 서비스의 요구 사항에 맞춰 결정된다.
-   예) 엔티티 '회원': 이름, 아이디, 주소, 전화번호 등의 속성을 가진다.

**약한 엔티티와 강한 엔티티**

-   엔티티 A가 혼자서는 존재하지 못하고 B의 존재 여부에 따라 종속적이면 A는 약한 엔티티, B는 강한 엔티티

---

### 📌 릴레이션

-   **데이터베이스에서 정보를 구분하여 저장하는 기본 단위**
-   엔티티에 관한 데이터를 릴레이션 하나에 담아서 관리한다.
-   **관계형 테이블(RDB)**에서는 '**테이블**' / **NoSQL 데이터베이스**에서는 '**컬렉션**'이라고 부른다.

**테이블과 컬렉션**

-   데이터베이스는 관계형 데이터베이스와 NoSQL 데이터베이스로 구분된다.
    -   관계형 데이터베이스 예시인 MySQL에서는 레코드(엔티티 하나) - 테이블 - 데이터베이스로 구성
    -   NoSQL 데이터베이스 예시인 MongoDB에서는 도큐먼트(엔티티 하나) - 컬렉션 - 데이터베이스로 구성

---

### 📌 속성

-   릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보(attribute)
-   서비스의 요구 사항을 기반으로 관리해야 할 필요가 있는 속성들만 엔티티의 속성이 된다.

---

### 📌 도메인

-   릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합(domain)
-   예) '성별'이라는 속성의 도메인 {남, 여}

---

### 📌 필드와 레코드

<img width="426" height="195" alt="image" src="https://github.com/user-attachments/assets/1989bee5-3b66-426d-bb16-ad582434d0d0" />

-   '회원'이라는 엔티티는 member라는 **테이블(릴레이션)**에서
-   이름, 아이디, 주소, 전화번호 등의 속성이 **필드**가 되어
-   테이블에 행(row)처럼 쌓이고, 이 행 단위의 데이터를 **레코드(튜플)**이라 한다.

#### 필드 타입 (MySQL 기준)

-   숫자 타입

| 타입 | 용량(바이트) | 최솟값(부호 있음) | 최솟값(부호 없음) | 최댓값(부호 없음) | 최댓값(부호 있음) |
| --- | --- | --- | --- | --- | --- |
| \`TINYINT\` | 1 | \-128 | 0 | 127 | 255 |
| \`SMALLINT\` | 2 | \-32768 | 0 | 32767 | 65535 |
| \`MEDIUMINT\` | 3 | \-8388608 | 0 | 8388607 | 16777215 |
| \`INT\` | 4 | \-2147483648 | 0 | 2147483647 | 4294967295 |
| \`BIGINT\` | 8 | \-2⁶³ | 0 | 2⁶³-1 | 2⁶⁴-1 |

-   날짜 타입

| 타입 | 지원 범위 | 용량 | 설명 |
| --- | --- | --- | --- |
| \`DATE\` | 1000-01-01 ~ 9999-12-31 | 3 | 날짜 부분은 있지만   시간 부분은 없는 값에 사용 |
| \`DATETIME\` | 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 | 8 | 날짜 및 시간 부분을 모두 포함하는 값에 사용   타임존과 무관하게 그대로 저장 |
| \`TIMESTAMP\` | 1970-01-01 00:00:01 ~ 2038-01-19 03:14:07 | 4 | 날짜 및 시간 부분을 모두 포함하는 값에 사용   내부적으로 UTC 기준으로 저장   → 조회 시 현재 세션의 타임존 기준으로 변환되어 출력됨      여러 지역(다른 타임존)에서 사용하는 서비스의 시간 기록    |

-   문자 타입
    -   \`CHAR\`
        -   고정 길이 문자열 (길이 0~255)
        -   유동적이지 않은 길이를 가진 데이터의 경우에 효율적이다.
        -   레코드를 저장할 때 무조건 선언한 길이 값으로 용량이 고정되어 저장된다.
        -   예) CHAR(100)으로 선언한 후 "abcdefghij"라는 10자를 저장하면 선언한 길이 값으로 고정해서 100바이트로 저장된다.
    -   \`VARCHAR\`
        -   가변 길이 문자열 (길이 0~65,535)
        -   유동적인 길이를 가진 데이터의 경우에 효율적이다.
        -   입력된 데이터에 따라 용량을 가변시켜 저장한다.
        -   예) 10글자의 단어를 저장하면 10글자에 해당하는 바이트 + 길이기록용 1바이트로 저장된다.
    -   \`TEXT\`
        -   큰 문자열 저장에 사용한다.
        -   주로 게시판의 본문을 저장할 때 사용한다.
    -   \`BLOB\`
        -   이미지, 동영상 등 큰 데이터 저장에 사용한다.
        -   보통은 AWS S3 등 서버에 파일을 올리고 경로를 VARCHAR로 저장하는 식이라 자주 사용하지 않는다.
    -   \`ENUM\`
        -   문자열 열거 타입
        -   {'small', 'medium', 'large'} 같은 리스트에서 하나만 선택 가능하고, 잘못된 값을 삽입하면 빈 문자열이 대신 삽입된다.
        -   ENUM을 사용하면 'small', 'medium' 대신 0, 1 등으로 매핑되어 메모리를 적게 사용한다.
        -   최대 65,535개의 요소들을 넣을 수 있다.
    -   \`SET\`
        -   문자열 열거 타입
        -   ENUM과 달리 여러 개의 데이터를 선택할 수 있다.
        -   비트 단위의 연산이 가능하며, 최대 64개의 요소를 넣을 수 있다.

---

### 📌 관계

데이터베이스에는 여러 테이블이 있고, 테이블 간의 관계는 화살표로 나타낸다.

<img width="1112" height="578" alt="image" src="https://github.com/user-attachments/assets/03fedb91-e9d1-47a8-9692-e0c9a247fe0a" />

#### 1:1 관계(One to One)

-   한 테이블의 한 행(row)이 다른 테이블의 한 행과만 연결되는 관계
-   예) 유저 - 유저 이메일 테이블: 하나의 유저는 하나의 이메일만 가진다.
-   두 테이블 중 하나가 다른 테이블의 PK를 FK로 참조한다.

#### 1:N 관계(One to Many)

-   한 테이블의 한 행이 다른 테이블의 여러 행과 연결되는 관계
-   예) 게시글 - 댓글: 하나의 게시글에 여러 댓글이 달릴 수 있다.
-   N쪽 테이블에 1쪽 테이블의 PK를 FK로 저장한다.

#### N:M 관계(Many to Many)

-   한 테이블의 여러 행이 다른 테이블의 여러 행과 연결될 수 있는 관계
-   예) 학생 - 수업: 한 학생은 여러 수업을 들을 수 있고, 하나의 수업에는 여러 학생이 참여할 수 있다.
-   직접 연결이 불가능하고, 중간 테이블이 필요하다.

| 관계 | 설명 | 구현 방식 | 예시 |
| --- | --- | --- | --- |
| **1:1** | 한 행 - 한 행 | 하나가 다른 테이블의 PK를 FK로 참조 | 유저 - 유저 이메일 |
| **1:N** | 한 행 - 여러 행 | N쪽 테이블에 FK | 게시글 - 댓글 |
| **N:M** | 여러 행 - 여러 행 | 중간 테이블 | 학생 - 수업 |

---

### 📌 키

-   알아야 하는 개념
    -   **유일성**: 중복되는 행이 없다.
        -   예) 주민등록번호는 모든 사람을 유일하게 식별할 수 있는 속성
    -   **최소성**: 키를 구성하는 속성 집합에서 불필요한 속성이 포함되지 않아야 한다.
        -   {주민등록번호, 이름}으로 키를 만든다면 유일성은 만족하지만 여기서 '이름'을 빼도 여전히 키로 사용 가능하므로 최소성을 만족하지 않는다.
        -   {주민등록번호} 만으로 키를 구성하면 불필요한 속성이 없으므로 최소성을 만족한다.

-   **기본키(Primary Key, PK)**
    -   테이블의 데이터 중 고유하게 존재하고, 중복된 값이 없는 속성
    -   유일성과 최소성 만족한다.
    -   자연키 또는 인조키 중에 골라 설정한다.
        -   자연키: 현실 세계에서 이미 존재하는 데이터 속성, 예) 주민등록번호, 학번
        -   인조키: 현실 데이터와 무관하게 DB가 임의로 생성한 식별자, 예) 행이 추가될 때마다 자동으로 매긴 순서
-   **외래키(Foreign Key, FK)**
    -   다른 테이블의 기본키를 그대로 참조하는 값으로, 개체와의 관계를 식별하는 데 사용
    -   중복되어도 괜찮다.
-   **후보키(candidate key)**
    -   기본키가 될 수 있는 후보들
    -   유일성과 최소성을 만족한다.
-   **대체키(alternate key)**
    -   후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 키들
-   **슈퍼키(super key)**
    -   각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키
    -   유일성은 만족하지만 최소성은 보장되지 않는다.

---

참고자료

[데이터베이스 - 필드, 레코드 , 타입](https://velog.io/@leesfact/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%ED%95%84%EB%93%9C-%EB%A0%88%EC%BD%94%EB%93%9C-%ED%83%80%EC%9E%85)
