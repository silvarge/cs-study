# 자료구조

## 1️⃣ 시간 복잡도 (Big-O 표기법)

- **정의**: 입력 크기에 따라 알고리즘이 실행되는데 걸리는 시간을 나타내는 척도,불필요한 연산을 제거하여 알고리즘 분석을 쉽게 할 목적으로 사용.컴퓨터 성능에 따라 실행시간은 달라질 수 있으므로 실제 실행 시간보다는 명령문의 실행 빈도수를 계산하여 실행 시간을 구하게 된다.
- **측정 방법**: 실제 실행시간(X) → 명령문의 실행 횟수(O) 기준으로 계산
- **의미**: 입력 크기 증가 시 알고리즘 효율성을 비교하는 기준
- **특징**: 수치가 작을수록 효율적인 알고리즘

<img width="604" height="427" alt="스크린샷 2025-10-03 오전 9 22 46" src="https://github.com/user-attachments/assets/27612048-1f3d-4528-8ce6-9efa4645a4f6" />

### 주요 시간 복잡도

- O(1) (상수 시간): 입력 크기와 상관없이 일정한 시간 (예: 배열 인덱스 접근)
<img width="555" height="546" alt="스크린샷 2025-10-03 오전 9 23 06" src="https://github.com/user-attachments/assets/1cd0a7f4-23b2-4775-b150-e7a66f334f3b" />

- O(n) (선형 시간): 입력 크기에 비례해서 처리 시간이 걸리는 알고리즘 (예: 순차 탐색)
<img width="563" height="650" alt="스크린샷 2025-10-03 오전 9 23 37" src="https://github.com/user-attachments/assets/6e638d60-ceab-4a42-92af-3e67365ab1e8" />

- O(n²): 입력 데이터 n만큼 반복하는데 그 안에서 N만큼 또 반복할 때의 표기 방법. 데이터 많아질 수록 수직상승 (예: 버블 정렬)
n만큼 반복하면서 그 안에서도 n만큼 반복하니까, 처리횟수가 n을 가로와 세로 길이로 가지는 면적만큼 늘어나게 된다. n이 증가할 때마다 가로와 세로 한 줄이 증가하므로 데이터가 커질수록 처리시간이 부담된다.
<img width="587" height="372" alt="스크린샷 2025-10-03 오전 9 24 01" src="https://github.com/user-attachments/assets/4286339a-71d1-4984-bc78-dc35b96faeb4" />

- O(nm): 서로 다른 입력 크기 n, m 에 따른 반복,n만큼 2번 반복하는 것이 아니라 n을 m만큼 반복한다.n> m 또는 n < m 이런 상황이 발생할 수 있다. O(n^2)랑 비슷하지만 n이 엄청 클수도 있고, m이 엄청 작을 수도 있다.
<img width="566" height="608" alt="스크린샷 2025-10-03 오전 9 24 34" src="https://github.com/user-attachments/assets/6ba240b2-0c9e-4a2e-ad4d-8f2dcdcd32a8" />
따라서 그래프도 O(n^2)랑 비슷하지만 상황에 따라 다르게 그려줘야한다.

- O(2^n): 지수적 증가 (예: 피보나치 재귀),매번 함수가 호출될 때마다 2번씩 호출하게 된다.이 호출하는 횟수는 트리의 높이만큼 반복된다. 따라서 O(2^n)의 시간 복잡도를 가지게 된다.즉, 모든 함수의 호출을 일일이 계산해야 한다.
<img width="626" height="309" alt="스크린샷 2025-10-03 오전 9 25 01" src="https://github.com/user-attachments/assets/9419bd72-cfcc-4d75-b0dd-a39474debd2a" />

- O(log n): 반으로 줄여가며 탐색 (예: 이진 탐색),데이터를 한 번 찾을 때마다 반틈씩 없어지는 알고리즘을 O(log n) 이라고 한다.이런 방식은 순차 검색 O(n)보다도 훨씬 빠르다.
<img width="567" height="209" alt="스크린샷 2025-10-03 오전 9 25 28" src="https://github.com/user-attachments/assets/82cba1c8-6bc8-4d43-a23b-e684bd6c9054" />

## 2️⃣ 공간 복잡도

- **정의**: 프로그램 실행 시 필요한 메모리 공간의 양
- **구성 요소**
    - 코드 영역
    - 정적 변수
    - 동적 재귀적인 함수 호출 스택
- **특징**: 메모리 발전으로 중요도는 과거보다 낮아졌지만, 대규모 시스템에서는 여전히 중요

## 3️⃣ 선형 자료구조

### 📍 연결 리스트 (Linked List)

- **구조**: `노드(Node) = 데이터 + 링크(포인터)`
    - **링크(포인터)**
        
        연결 리스트에서 각 노드가 다음 노드를 가리키는 역할을 합니다. 
        
- **특징**
    - 동적 크기 조절 가능: 요소의 추가나 삭제에 따라 리스트의 크기가 증가하거나 감소할 수 있습니다.
    - 공간 효율성 극대화:각 노드는 필요한 만큼의 메모리를 차지하고, 요소의 추가 또는 삭제에 따라 메모리를 동적으로 할당하거나 해제할 수 있습니다.
    - 데이터 추가와 삭제 많이할때: 연결 리스트의 시작 또는 끝에 요소를 추가하거나 삭제하는 작업은 상수 시간에 이루어집니다. 하지만 특정 위치에 있는 요소에 접근하려면 포인터를 따라가야 하므로 선형 시간이 걸립니다.
    - 큐(Queue)나 스택(Stack)과 같은 자료구조를 구현할 때 많이 활용
    - 삽입/삭제: O(1) (노드 참조 알고 있을 때)
    - 탐색: O(n) (순차 접근 필요)
- **종류**
    - **단일 연결 리스트 (Singly Linked List)**: `next`만 존재,데이터의 삽입과 삭제가 빠르며 메모리 공간을 효율적으로 사용, 삽입 또는 삭제하는 경우에는 단순히 링크를 변경,데이터의 검색에는 선형적인 탐색이 필요하므로 효율성이 떨어질 수 있습니다. 특정 위치의 요소에 접근하기 위해서는 ‘헤드부터 순차적으로 탐색’ 해야 한다는 단점,스택(Stack)이나 큐(Queue)와 같은 다른 추상 자료형을 구현하는 데에도 활용
      <img width="570" height="131" alt="스크린샷 2025-10-03 오전 9 26 01" src="https://github.com/user-attachments/assets/9a02638c-5751-4e21-af2f-0dccef1e6166" />
    - 이중 연결 리스트 (Doubly Linked List): prev, next 모두 존재 → 양방향 탐색 가능, 어떤 위치의 노드에서도 앞과 뒤의 노드에 접근할 수 있습니다.단순 연결 리스트와 달리 양방향으로 순회할 수 있으며, 양쪽 방향에서의 삽입과 삭제가 가능합니다. 이는 데이터의 검색과 수정을 효율적으로 처리할 수 있는 장점을 제공합니다.그러나 각 노드가 이전 노드와 다음 노드를 가리키는 링크를 유지해야 하므로, 메모리 사용량이 증가하게 됩니다.이중 연결 리스트는 데이터의 삽입 및 삭제 작업이 빈번하게 발생하는 상황에서 유용하게 사용됩니다. 또한, 이중 연결 리스트를 기반으로 구현된 많은 알고리즘과 데이터 구조가 존재,사용 예시: LRU 캐시 등
      <img width="563" height="80" alt="스크린샷 2025-10-03 오전 9 26 43" src="https://github.com/user-attachments/assets/740b7633-07b5-4d7e-918c-22b7dc0c003b" />
    - 원형연결리스트: 이중연결리스트와 같지만 마지막 노드의 next가 헤드 노드를 가리킴
    
    **마지막 노드가 첫 번째 노드를 가리키는 형태로 이루어져 있는 자료구조입니다. 즉 리스트가 끝에서 시작으로 연결되는 원형 구조를 가지고 있습니다. 이러한 특성으로 인해 마지막 노드의 다음 노드가 첫 번째 노드가 되며, 첫 번째 노드의 이전 노드가 마지막 노드가 됩니다.**
    
    순환 연결 리스트는 데이터의 삽입과 삭제를 빠르게 처리할 수 있는 장점이 있습니다. 또한, 리스트의 시작과 끝이 연결되어 있으므로 순환 구조를 이용한 다양한 알고리즘을 구현할 수 있습니다.
    
    그러나 순환 연결 리스트를 순회하는 경우 무한 루프에 빠질 수 있으므로 조심해야 합니다.
    
    순환 연결 리스트는 리스트의 순서를 계속해서 이동하면서 작업을 수행해야 하는 경우에 유용합니다. 예를 들어, 원형 큐(Circular Queue)나 원형 버퍼(Circular Buffer)와 같이 순환적인 동작이 필요한 자료 구조에서 사용됩니다. 또한, 순환 연결 리스트는 알고리즘에서 반복적인 동작을 처리하는 데에도 활용될 수 있습니다.
    <img width="543" height="131" alt="스크린샷 2025-10-03 오전 9 27 23" src="https://github.com/user-attachments/assets/8c1d6c06-bcac-4c63-a563-bc5513c07435" />

### 배열 (Array)

- **구조**: 같은 타입의 데이터가 연속된 메모리 공간에 저장
- **특징**
    - 중복허용
    - 순서 존재
    - 조회 많이할 때
    - 접근: O(1) (랜덤 접근 가능)
    - 삽입/삭제: O(n) (데이터 이동 필요)
    - 정적 크기 (생성 시 크기 고정)
- **장점**: 조회 성능 우수
- **단점**: 크기 변경 불가, 삽입/삭제 비효율적
- 종류
    - 1차원 배열: 중첩이 없는 경우, 배열의 요소가 배열이 아닌 경우
        
        예) {1, 2, 3, 4, 5}, {1, 3, 5, 7, 9}, {가, 나, 다, 라}, {a, b, c, d, e}, … 등
    - 2차원 배열: 배열이 한번 중첩된 경우,배열의 요소가 배열
    
    예) {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}}, {{a, b, c, d}, {e, f, g, h}}, … 등

<img width="562" height="229" alt="스크린샷 2025-10-03 오전 9 28 20" src="https://github.com/user-attachments/assets/0425eb38-6922-4614-a230-cebc2878d591" />
<img width="554" height="315" alt="스크린샷 2025-10-03 오전 9 28 27" src="https://github.com/user-attachments/assets/bc42bca3-e175-4505-bda0-5eeb5ca529b5" />

### 벡터 (Vector, 동적 배열)

- **구조**: 동적 크기 조정이 가능한 배열 기반 자료구조
- **특징**
    - 중복 허용
    - 랜덤 접근: O(1)
    - 삽입/삭제(맨 끝): O(1)
    - 삽입/삭제(중간): O(n)
- **장점**: 크기 자동 확장, 배열처럼 인덱스로 접근 가능
- **단점**: 연속 메모리 사용 → 중간 삽입/삭제 비효율적
- **사용 시점**
    - 데이터 개수가 가변적일 때
    - 조회는 많지만 삽입/삭제는 주로 끝에서만 발생할 때

자바 버전1 서부터 있었던 굉장히 오래된 클래스이기 때문에 여러모로 취약점이 많고, 또한 상속으로 인한 부모 메서드 공유 문제 때문에 사용자가 잘못되게 사용될 수 있다는 큰 문제점이 있다.

## 1️⃣ 스택 (Stack)

<img width="588" height="300" alt="스크린샷 2025-10-03 오전 9 29 24" src="https://github.com/user-attachments/assets/b0805fa2-d96e-4d16-8ec4-15e70ede208f" />

- **구조**: LIFO (Last In, First Out, 후입선출)
- **연산**
    - `push`: 데이터 삽입
    - `pop`: 데이터 삭제 (맨 위)
    - `peek`: 맨 위 데이터 확인 (삭제 X)
- **시간 복잡도**
    - 삽입/삭제: O(1)
    - 탐색: O(n)
- **활용**
    - 재귀 함수 호출 (호출 스택)
    - DFS(깊이 우선 탐색)
    - JVM Runtime Data Area의 Stack 영역 (지역 변수 저장, 함수 호출 관리)
- **자바 구현**
    - `Stack` 클래스는 설계 문제로 권장 ❌
    - `Deque` 인터페이스 활용 권장 (양방향 입출력 지원)
 
<img width="631" height="496" alt="스크린샷 2025-10-03 오전 9 29 42" src="https://github.com/user-attachments/assets/500317ad-7a67-4238-b93b-888dc0a88d99" />

## 2️⃣ 큐 (Queue)

- **구조**: FIFO (First In, First Out, 선입선출)
- **연산**
    - `enqueue`: 데이터 뒤쪽 삽입 (rear)
    - `dequeue`: 데이터 앞쪽 제거 후 반환 (front)
- **시간 복잡도**
    - 삽입/삭제: O(1)
    - 탐색: O(n)
- **활용**
    - BFS(너비 우선 탐색)
    - CPU 프로세스 스케줄링
    - 캐시 구현
    - Queue를 지원해주진 않기 때문에 배열이나 LinkedList로 구현(큐를 사용할 때는 push, pull, isEmpty 등 여러 함수를 발생시킬 수 있음)

### 큐의 변형

1. **원형 큐 (Circular Queue)**
    - front와 rear를 포인터로 순환 관리: 값이 추가, 삭제 되어도 유동적으로 포인터값이 바뀌어서 작업을 수행
        - Enqueue : Rear 부분에 추가된 값이 추가, Rear 포인터도 +1
        - Dequeue : Front 부분의 값 삭제, front 포인터 +1
    - 메모리 효율 ↑
    - O(1)
    
    <img width="515" height="545" alt="스크린샷 2025-10-03 오전 9 30 20" src="https://github.com/user-attachments/assets/a6cc1998-57e3-4e01-9834-b46b701ae5ae" />

2. **우선순위 큐 (Priority Queue)**
    - 우선순위 높은 요소 먼저 꺼냄 : 삽입될 때 우선순위 파악한 뒤 정렬
    - 힙(Heap)으로 구현
    - 삽입/삭제: O(log n)
    - `Insert`  : 값 삽입
    - `Delete`:삭제
    - `Reek or Pop`: 우선순위가 크거나 작은 값 조회
    - 활용: 다익스트라 최단경로, 작업 스케줄링
    
    <img width="589" height="309" alt="스크린샷 2025-10-03 오전 9 30 32" src="https://github.com/user-attachments/assets/d1f9b1da-ce53-40f6-a060-fa6700fa13bf" />

    오른쪽에 있는 배열이 힙 영역입니다.
    
    해당 배열에 값을 넣을 때 비교하면서 넣는 다는 특징을 가지고 있습니다.
    
    **시간 복잡도 : O(log n)**
    
3. **덱 (Deque; Double Ended Queue)**
    
    <img width="594" height="131" alt="스크린샷 2025-10-03 오전 9 31 07" src="https://github.com/user-attachments/assets/6a629cd6-4d71-456b-9466-8209fbe13109" />

    - 양쪽에서 삽입/삭제 가능
    - 스택과 큐 연산 모두 지원
    - 동적 배열, 이중 연결리스트 등 사용 가능
    - `PushFront`: 덱의 앞부분에 요소를 추가합니다.
    - `PushBack`: 덱의 뒷부분에 요소를 추가합니다.
    - `PopFront:` 덱의 앞부분에서 요소를 제거하고 반환합니다.
    - `PopBack:` 덱의 뒷부분에서 요소를 제거하고 반환합니다.
    - `Front/Back:` 각각 덱의 앞부분과 마지막 부분에 있는 요소를 조회(peek)하는 연산입니다.
    - O(1)
4. **블로킹 큐 (Blocking Queue)**
    - 멀티스레드 환경에서 **스레드 동기화** 지원
    - `프로듀서-컨슈머 패턴`에 활용
        - 프로듀서 : 데이터를 생성하고 버퍼에 추가(Enqueue)하는 역할,새로운 데이터가 생성될 때마다 이것을 큐에 추가
        - 컨슈머 : 버퍼에서 삭제(Dequeue)하는 역할,필요한 데이터가 있다면 큐에서 꺼내어 사용
    - 데이터가 없으면 소비자가 대기, 공간 없으면 생산자가 대기
  
## 참고자료
https://adjh54.tistory.com/319

https://ssdragon.tistory.com/100#O-n-

[https://ssdragon.tistory.com/100#O-n-
](https://gamza1013.tistory.com/71)

https://velog.io/@nnnyeong/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EB%B2%A1%ED%84%B0-Vector

https://ittrue.tistory.com/115#google_vignette
https://ssdragon.tistory.com/100

