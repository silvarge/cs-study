# 선형 자료 구조 (Linear Data Structure)

자료를 구성하는 원소들을 하나씩 순차적으로 나열시킨 형태

- 정적 자료 구조: 프로그램 실행 중 크기가 고정되어 있는 자료 구조
    - 예시: 배열
    - 미리 할당된 메모리 공간에 데이터를 저장하기에, 데이터 추가/삭제/크기 변경 등이 제한적
- 동적 자료 구조: 프로그램 실행 중 크기가 동적으로 조정될 수 있는 자료 구조
    - 예시: 연결 리스트, 큐, 스택 등
    - 필요에 따라 메모리에서 유연하게 공간을 할당하고 해제해 데이터를 저장할 수 있어 데이터 추가/삭제/크기 변경 등이 가능
  
<img width="1399" height="1511" alt="image" src="https://github.com/user-attachments/assets/c5037597-961d-408d-9e3a-cc9847cf62fc" />
요 부분을 공부해 볼 것이다.

# 배열 (Array)

> 동일한 자료형의 원소들을 **연속적인 메모리 공간**에 저장하는 자료 구조
> 

<img width="610" height="264" alt="image" src="https://github.com/user-attachments/assets/ce1207ce-37d9-44f9-b93b-9bc4f9e6f355" />

- 인덱스와 값(Value)으로 구성
- 배열 선언 시 크기를 지정해야 함 (크기가 고정됨)
- 데이터가 저장되는 순서 = 데이터가 나열된 순서 (논리적 저장 순서 = 물리적 저장 순서)
- Cache hit rate가 높음
- 추가적으로 소모되는 메모리의 양(오버헤드)가 거의 없음

## 언제 사용할까?

- 데이터의 개수가 정해져 있는 경우
- 데이터의 수정이 적은 경우
- 데이터의 검색이 빈번할 경우

## 시간 복잡도

### 삽입/삭제

- 배열의 맨 앞에 삽입/삭제: O(N)
- 배열의 맨 뒤에 삽입/삭제: O(1)
- 배열의 중간에 삽입/삭제: O(N)

⇒ 맨 뒤라면 상관 없지만, 앞/중간이라면 삽입할 위치 뒤에 있는 데이터를 다 밀어내야(Shift) 한다는 점

### 탐색

- 원소에 접근: O(1)

⇒ 배열의 원소가 인덱스와 값으로 이루어져 있기 때문

## 장단점

### 장점

- 인덱스를 통한 빠른 접근이 가능
- 연속된 메모리 공간에 존재하기에 관리가 수월
- 저장 효율이 뛰어남 (추가적으로 소모되는 메모리의 양(오버헤드)이 거의 없다)

### 단점

- 삽입과 삭제가 번거롭고 시간이 오래 걸림 (삽입/삭제 완료 후 비어 있는 공간을 메우는 과정(shift) 필요)
- 크기가 고정되어 있기에 유연한 자료 구조는 아님

# 연결 리스트 (Linked List)

> 같은 특성을 갖는 원소들이 순서대로 구성되어 있지만, 데이터가 **연속적으로 저장되지 않는** 자료 구조
> 

<img width="961" height="109" alt="image" src="https://github.com/user-attachments/assets/3182bb2c-76e6-4868-bafa-5e059ecfa965" />

- 리스트의 첫 번째 노드를 헤드(HEAD), 마지막 노드를 테일(TAIL)이라고 한다.
- 노드를 통해 포인터를 이용하여 연결된 구조
- 데이터가 들어올 때마다 동적으로 메모리 할당 - 크기가 고정되어 있지 않음
- 각 노드의 테일에는 다음 노드의 주소 정보를 저장하여 해당 주소 정보를 통해 원소를 탐색
- 데이터가 불연속적인 메모리 공간에 위치하고 있어도 주소 정보를 통해 탐색 가능

## 언제 사용할까?

- 저장할 원소들의 사이즈를 확실하게 모를 때 (유연성이 필요할 때)
- 삭제/삽입이 활발히 일어날 때

## 시간 복잡도

### 삽입

- 리스트의 맨 앞에 삽입: O(1)
- 리스트의 중간에 삽입: O(n)

### 삭제

- 리스트의 맨 뒤에 삽입/삭제: O(1)
- 리스트의 중간에서 삭제: O(N)

### 탐색

- 탐색: O(N)

⇒ 인덱스 접근이 불가해 처음부터 링크를 타며 순차적으로 탐색이 필요

## 장단점

### 장점

- 크기가 가변적 (유연함)
- 삽입/삭제가 용이
- 빈 공간을 허용하지 않기에 메모리 낭비가 없다 (배열은 빈 공간이 존재할 수 있음)
- 사용한 메모리도 재사용이 가능

### 단점

- 데이터 접근 속도가 상대적으로 느림 (연속적인 메모리 공간이 아니기에 탐색이 순차적)
    - 인덱스가 존재하지 않아서…
- Cache Hit Rate가 낮다
- 별도의 주소를 저장하는 공간이 필요하기에 값 저장 외의 추가적인 메모리가 필요

## 리스트와 배열의 차이점

둘의 가장 큰 차이점은 **인덱스의 유무**와 **연속적으로 메모리에 저장되는지 여부**이다.

일반적으로는 리스트(List)라고 하면 연결 리스트를 의미하는 경우가 많다.

자료 구조 관점에서는 배열 또한 리스트에 포함된다.
하지만, 프로그래밍 언어의 관점으로 리스트는 배열이 가지고 있는 인덱스라는 장점을 버리고
빈틈없는 데이터의 적재라는 장점을 취한 인터페이스라고 할 수 있다.

## 리스트의 종류

- 링크드 리스트 (Single Linked List)
    
    한 방향(HEAD→TAIL)으로 연결되어 있는 연결 리스트
    
    <img width="934" height="109" alt="image" src="https://github.com/user-attachments/assets/cb19ba92-e044-4111-9d3b-72f5d86a2c66" />
    
- 더블 링크드 리스트 (Double Linked List)
    
    양방향으로 연결되어 있는 연결 리스트
    
    <img width="996" height="109" alt="image" src="https://github.com/user-attachments/assets/a5245a85-e847-47e8-bbee-73ee2b1b1a11" />
    
- 순환 링크드 리스트 (Circular Linked List)
    
    한 방향으로 연결되어 있지만, 마지막 노드(TAIL)은 첫 번째 노드(HEAD)를 가리키고 있는 연결 리스트
    
    <img width="1014" height="146" alt="image" src="https://github.com/user-attachments/assets/ff74641f-5c14-4254-bc67-f7391ee3548b" />
    
- 순환 더블 링크드 리스트 (Doubly Circular Linked List)
    
    양방향으로 연결되어 있고, 테일은 다음 노드로 헤드를 가리키고, 헤드는 이전 노드로 테일을 가리키고 있는 연결 리스트
    
    <img width="1077" height="192" alt="image" src="https://github.com/user-attachments/assets/2083538c-5067-48cd-a058-fc1c3207f4cc" />
    

# 벡터 (Vector)

> 동적 배열 구조 클래스
> 
- 말 그대로, 크기를 조정할 수 있는 배열 (가변 길이)
- 배열의 단점인 고정된 크기를 보완한 것
- 추가되는 요소의 개수에 따라 자동적으로 크기가 조절
- 벡터의 제일 뒤에서만 삽입/삭제가 일어남

## 언제 사용할까?

- 저장할 데이터 개수가 가변적일 때
- 중간에 데이터 삽입/삭제가 없을 때
- 저장할 데이터 개수가 적거나 많은 경우
- 데이터 접근 시 랜덤 접근을 하고 싶을 때

## Java의 벡터

자바에서는 벡터가 존재는 하는데, 거의 쓰지 않는다.
자바의 Vector는 ArrayList와 동일한 구조를 가지고 있는데, 장점이자 단점이 존재한다.

그것은 항상 동기화된다는 것인데, 스레드가 1개일 때도 동기화를 하기에 ArrayList보다 성능이 떨어진다.
ArrayList는 벡터와 동일한데, 자동 동기화 기능이 빠져 있고, 동기화 옵션이 존재한다.

내가 생각해도 옵션으로 선택할 수 있고 성능이 뛰어난 ArrayList를 쓸 것 같긴 하다.
또한, 찾아보니 Vector의 경우 초기에 만들어진 인터페이스라 초기 버전 호환성이 아니라면 많이 쓰지 않는다고 한다.

꼭 사용해야 할 이유가 없다면 굳이?

# 스택 (Stack)

후입선출(Last-In First-Out) 형태의 선형 자료구조

<img width="720" height="550" alt="image" src="https://github.com/user-attachments/assets/faaddfea-cf9d-4689-a0ae-96b1af90f83a" />

- 가장 마지막에 들어온 데이터가 가장 먼저 나간다
- 자료의 입출력이 한 방향으로 제한되어 있다
- 위쪽만 뚫려 있는 그릇에 하나씩 쌓아간다고 생각하면 된다
- 일반적으로 Push를 통해 데이터를 맨 위에 추가하고, Pop을 통해 맨 위의 데이터를 제거한다
- 사용 단어
    - Bottom: 가장 밑의 데이터/인덱스
    - Top: 가장 위의 데이터/인덱스
    - Capacity: 스택에 담을 수 있는 데이터의 총량
    - Size: 현재 스택에 담겨져 있는 데이터의 개수

## 언제 사용할까?

- 뒤로 가기, 실행 취소처럼 직전에 했던 내용들만 조회하면 되는 상황일 때
- 데이터를 쌓아야 할 때
- 컴퓨터 연산

## 시간 복잡도

### 삽입

- O(1)

### 삭제

- O(1) - pop()을 이용하여 맨 위의 값을 제거했을 때

### 검색

- 최악: O(N)

## 장단점

### 장점

- 단순하고 간단한 구조
    - 간단한 원칙에 따라 동작하는 자료구조
    - 구현이 비교적 쉬움
    - 데이터의 추가와 제거가 매우 빠르게 이루어짐
- 메모리 관리 용이
    - 정해진 크기의 메모리를 사용 → 메모리 관리 간단
    - 필요한 만큼의 공간만 사용하고 남는 공간이 없다

### 단점

- 크기 제한
    - 정적인 크기를 가지고 있어 크기가 제한되어 있다
    - 크기를 초과하는 경우, 오버플로우 발생
- 중간 데이터 접근의 어려움
    - 데이터는 맨 위에서만 추가되고 제거됨
    - 중간에 있는 데이터에 접근하기 위해서는 맨 위의 데이터를 순차적으로 제거해야 함
    - 중간 데이터에 빈번하게 접근해야 하는 경우, 효율적인 자료구조가 아님

# 큐 (Queue)

먼저 들어간 데이터가 나오는 선입선출(First-In First-Out) 형태의 선형 자료구조

<img width="1152" height="411" alt="image" src="https://github.com/user-attachments/assets/9fb95fa6-3f06-453f-82c2-31513c29ef1f" />

- 처음 들어온 값이 처음에 나가고, 마지막에 들어온 값이 마지막에 나가는 것
- 자료의 입출력이 한쪽 끝으로 제한되어 있음
    - 큐의 제거는 front에서만 일어나고 삭제는 항상 rear에서만 일어남

## 언제 사용할까?

- 임시로 자료를 저장, 버퍼 등
- 우선 들어온 데이터가 우선 처리되어야 하는 상황
- 순서를 보장해줘야 하는 상황
- 대기열

## 시간 복잡도

### 삽입

- O(1)

### 삭제

- Dequeue: O(1)
- Remove: O(n)

### 검색

- O(n)

⇒ 큐의 삽입은 rear에서만 일어나고, 삭제는 front에서만 일어나므로,
삽입과 삭제에 소요되는 시간복잡도는 O(1)로 고정

## 장단점

### 장점

- 특정 작업을 처리하는 순서를 보장하는 데 유용
    - 선입선출 원칙을 따르기 때문
- 크기 조절 가능
    - 동적으로 크기 조절 가능
    - 필요에 따라 크기를 늘리거나 줄이기 가능
- 대기열 관리
    - 작업을 처리하기 위해 들어오는 요청을 큐에 저장하고 처리 우선순위에 따라 처리할 수 있음

### 단점

- 중간 항목 접근 어려움
    - 데이터의 삽입과 삭제가 각각 한쪽 끝에서만 일어남
    - 중간에 위치한 특정 항목에 접근하기 어려움
    - 중간 항목에 접근해야 한다면 큐와 어울리지 않으니 다른 자료구조를 고려해보자
- 크기 제한
    - 일반적으로 동적 크기 조절이 가능하지만, 특정 구현에서는 크기가 제한되어 있을 수 있다
    - 큐가 가득 찬 상태에서 더 많은 항목을 삽입하려고 하면 오버플로우가 발생할 수 있음
- 선형 탐색 시간
    - 특정 항목을 찾기 위해서는 큐를 선형적으로 탐색해야 함
    - 큐에서 특정 항목을 찾는 데 걸리는 시간은 큐의 크기에 비례

## 큐의 종류

- 선형 큐 (Linear Queue)
    - 가장 기본적인 큐
- 환형 큐 (Circular Queue)
    - 큐의 마지막 요소와 첫 요소가 연결된 큐
    - 원형으로 순환
- 우선순위 큐 (Prority Queue)
    - 각 데이터 요소에 우선순위를 할당하고, 해당 우선순위에 따라 데이터 처리
- 데크 (Deque; Double Ended Queue)
    - 양쪽에서 삽입, 삭제가 가능한 구조
    - 보통 스케줄링에 많이 사용

## 자바에서의 큐

- 일반적으로는 LinkedList를 통해 구현된다.
배열로도 생성이 가능하지만, 대부분 연결리스트를 사용한다.
    
    ```java
    Queue<E> queue = new LinkedList<E>();
    ```
    
- 우선순위 큐, Deque 등 구현할 수 있다.

# 참고자료

[**면접을 위한 CS 전공지식 노트_주홍철**](https://product.kyobobook.co.kr/detail/S000001834833)

[**이것이 자료구조+알고리즘이다 with C 언어_박상현**](https://product.kyobobook.co.kr/detail/S000061585515)

https://bigsong.tistory.com/31

https://kkangdda.tistory.com/30

https://ongveloper.tistory.com/403

https://blog.naver.com/kkkths/221760312903

https://bigsong.tistory.com/32
