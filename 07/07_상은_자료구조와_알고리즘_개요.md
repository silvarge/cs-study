# 자료구조

> 데이터를 표현하거나 저장하는 방법
> 
- 개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방법
- 각각의 자료구조에는 장단점이 존재하므로, 어떤 자료구조가 최선일지는 해결하고자 하는 문제의 종류와 어떤 부분을 우선적으로 최적화 할 지에 따라 달라질 수 있음
- 연산 방법과 목적에 따라 다양한 자료구조가 있다

# 자료구조의 분류

<img width="1350" height="1511" alt="image" src="https://github.com/user-attachments/assets/e20127ae-288f-45c3-bcca-e065141a9bbf" />

일반적으로 이와 같이 나누는데, `선형 구조`와 `비선형 구조`를 주로 공부한다고 보면 된다.

## 선형 구조

데이터가 순서대로 정렬된 직선 연결 구조로 모든 요소가 하나의 경로로 연결되어 있다.

주로 순차적으로 데이터를 처리하는 데 사용

## 비선형 구조

데이터가 비연속적, 계층적이거나 복잡하게 연결된 구조

요소 간 여러 경로를 가짐

## ADT (추상 자료형, Abstract Data Type)

스택이나 큐 등을 보다보면 ADT라는 단어를 많이 볼 수 있다.

여기서 ADT는 추상 자료형으로, 데이터 타입과 그 데이터와 관계된 연산들을 수학적으로 정의만 한 것이다.

구현되어 있지 않고, 단순히 형태와 그 연산만 추상적으로 정의를 한 상태인 것이다.

Java에서 Interface를 사용하려면 이를 implement하여 구현체를 만들어야 하는데, 이와 비슷하다고 보면 된다.

# 알고리즘

> 문제를 해결하기 위한 절차나 방법
> 
- 어떤 작업을 수행하기 위한 과정을 애매하지 않게 기술한 것
- 저장된 데이터를 이용하여 문제를 해결하기 위한 절차나 방법을 의미

### 알고리즘의 조건

- 입력: 0개 이상의 입력이 존재해야 한다
- 출력: 1개 이상의 출력이 존재해야 한다
- 명백성: 각 명령어의 의미는 모호하지 않고 명확해야 한다
- 유한성: 한정된 수의 단계 후 반드시 종료가 되어야 한다
- 유효성: 각 명령어들은 실행 가능한 연산이어야 한다

### 알고리즘 선택

문제를 푸는 방식은 다양하다, 따라서 적용 가능한 알고리즘도 다양하다.

언제나 자원은 한정되어 있기 때문에 가능한 한 빠르게, 적은 리소스로 문제를 해결하는 것이 중요하다.

이러한 좋은 성능을 낼 수 있도록 최적의 알고리즘을 선택하는 것이 중요하다.

일반적으로 빅-오 표기법 등, `복잡도`라는 수치를 고려하여 알고리즘의 성능을 판단하고 선택하는 경우가 많다.

### 알고리즘 표현 방법

알고리즘은 절차나 방법을 묘사하는 것이다.
따라서 이에 대한 표현 방법이 다양하다.

- 자연어를 이용한 서술적 표현 방법
- 순서도를 이용한 도식화 표현 방법
    - 알고리즘 흐름 파악 용이
    - 복잡한 알고리즘 표현이 어려움
- 프로그래밍 언어를 이용한 구체화 방법
- 가상 코드(Pseudo-code)를 이용한 추상화 방법
    - 가상 코드를 이용한 알고리즘의 표현
    - 알고리즘 기술 언어(ADL; Algorithm Description Language)를 사용하여 프로그래밍 언어의 일반적인 형태와 비슷하게 알고리즘 표현
    - 직접 실행은 불가능 (특정 언어는 아니므로)
    - 원하는 프로그래밍 언어로 변환하기에 용이

# 자료구조와 알고리즘

알고리즘은 문제 해결을 위한 과정을 기술하고, 그 때 자료구조는 부품과도 같은 역할을 한다.

# 알고리즘 성능 분석 방법

효과적인 알고리즘을 얻기 위해 알고리즘의 성능을 분석하고 평가할 수 있어야 한다.
일반적으로 시간과 메모리 두 자원이 알고리즘의 효율성을 측정하는 척도가 된다.

기본적으로 복잡도라고 하는데, 알고리즘의 수행 시간을 분석한 결과는 `시간 복잡도(Time Complexity)`라고 하고, 메모리 사용량을 분석한 결과는 `공간 복잡도(Space Complexity)`라고 한다.

## 복잡도 (Complexity)

하드웨어 성능이 발전함에 따라 알고리즘이 돌아가는 메모리가 충분해지기도 하고,
시간 복잡도와 공간 복잡도는 반비례하는 경향이 있어,

보통 알고리즘의 성능을 파악할 때는 `시간 복잡도`를 위주로 판단한다.

### 공간 복잡도 (Space Complexity)

알고리즘 수행 과정에서 얼마나 많은 공간(메모리)를 차지하는가

- 알고리즘을 실행시키기 위해 필요한 공간은 두 가지로 나눌 수 있다
    - 고정 공간 (알고리즘과 무관한 공간)
        - 코드가 저장되는 공간
        - 알고리즘 실행을 위해 시스템이 필요로 하는 공간
    - 가변 공간 (알고리즘과 밀접한 공간)
        - 문제 해결을 위해 알고리즘이 필요로 하는 공간
        - 변수 저장 공간, 순환 스택 등

### 시간 복잡도 (Time Complexity)

**실행 명령어의 실행 횟수**

- 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수
- 알고리즘이 데이터를 처리하는 데 얼마나 걸리는가
    - 시간이라고 하지만, 실행 시간이 아닌 연산 횟수를 세는 이유는 모든 OS, IDE, 플랫폼에서 동일한 결과가 나오지 않기에…

# 점근 표기법

컴퓨터 알고리즘의 실행 시간은 실행 환경에 따라 다르게 측정된다.

따라서, 실행 환경을 동일하게 하는 것은 어렵기에 기본 연산(산술/제어 연산 등)의 실행 횟수로 성능을 분석한다.

함수가 복잡할수록 어느 알고리즘이 효율적인지 비교하는 것은 어려워지기 때문에, 함수를 단순화하기 위해 점근 표기법을 사용하여 표기하는 것이다.

함수의 증가율에 따른 다른 함수와 비교하는 것이 목표이기에 최고차항을 제외한 모든 항과 최고차항의 계수는 무시하여 O(n), O(logN), O(n²) 등으로 표시한다. (최고차항이 가장 영향력이 높기에)

## 점근 표기법의 종류

- 빅-오 표기법 (Ο): 최악의 경우
- 빅-오메가 표기법 (Ω): 최선의 경우
- 빅-세타 표기법 (Θ): 평균적인 경우

그 중에서 가장 많이 쓰이는 표기법은 `빅-오 표기법`이다.
최악의 경우에도 해당 알고리즘이 어떤 성능을 낼 수 있는지 가늠해볼 수 있기 때문.

## 빅-오 표기법 (Big-Ο Notation)

> 알고리즘의 성능이 최악의 경우라도 g(n)이상
> 

$$
f(n) = O(g(n))
$$

이때 g(n)을 함수 f(n)의 **점근적 상한**이라고 한다.

f(n)의 복잡도는 최악의 경우라도 g(n)보다 작거나 같다는 의미 (`f(n) ≤ g(n)`)

## 빅-오메가 표기법 (Big-Ω Notation)

> 알고리즘의 성능이 아무리 빨라도 g(n) 이하
> 

$$
f(n) = Ω(g(n))
$$

이때 g(n)을 함수 f(n)의 점근적 하한이라고 한다.

f(n)의 복잡도는 최선의 경우라도 g(n)보다 크거나 같다는 의미 (`f(n) ≥ g(n)`)

## 빅-세타 표기법 (Big-Θ Notation)

> 알고리즘의 성능이 g(n)의 상한과 하한에 포함(그 사이에 있다)
> 

$$
f(n) = Θ(g(n))
$$

이때 g(n)을 함수 f(n)의 **점근적 상한 및 하한**이라고 한다.

f(n)의 복잡도가 최선의 경우나 최악의 경우라도 g(n)의 범위 안에 있다는 의미 (대략 `f(n) = g(n)`)

# 시간 복잡도와 빅-오 표기법

그렇다면 일반적으로 빅-오 표기법을 사용하기에, 이를 기준으로 많이 사용되는 복잡도가 무엇이 있을 지 확인해보려고 한다.

이와 같이 빅-오 복잡도 그래프가 존재하는데, O(NlogN)부터 이제 슬슬 나쁜데~ 정도로 말하기 시작한다.

![빅-오 복잡도 표 (https://www.bigocheatsheet.com/)](attachment:62f816cb-fa81-4943-9fd9-9c030771900d:image.png)

빅-오 복잡도 표 (https://www.bigocheatsheet.com/)

아래 표에서 아래로 갈 수록 성능이 떨어지고, 시간 복잡도가 좋지 않은 알고리즘이라고 보면 된다.

| 표기 | 이름 | 시간 복잡도 | 설명 | 예시 |
| --- | --- | --- | --- | --- |
| O(1) | 상수 | 상수 시간 | 입력 크기와 상관 없이 일정한 실행 시간 | 충돌이 없는 해시 테이블 조회 |
| O(logN) | 로그 | 로그 시간 | 입력 크기가 증가함에 따라 실행 시간이 로그 함수의 형태로 증가 | 이진 탐색 |
| O(N) | 선형 | 선형 시간 | 입력 크기와 비례 | 선형 탐색, 단순 for 문 |
| O(NlogN) | 로그 선형 | 선형 로그 시간 | 입력 크기가 증가함에 따라 실행 시간이 로그 함수와 선형 함수의 곱의 형태로 증가 | 병합 정렬, 힙 정렬 |
| O(N²) | 이차 (2차) | 2차 시간 | 입력 크기의 제곱에 비례 | 선택 정렬, 버블 정렬, 이중 for 문 |
| O(2ⁿ) | 지수 | 지수 시간 | 입력 크기의 지수에 비례 | 부분 집합 |
| O(n!) | 계승 | 팩토리얼 시간 | 입력 크기의 팩토리얼에 비례 | 외판원 문제 |

### 내 코드에서 시간 복잡도를 구하는 팁

- 하나의 반복문을 사용하여 단일 요소 집합을 반복하는 경우: `O(N)`
- 컬렉션의 절반 이상을 반복하는 경우: O(N/2) = `O(N)`
- 두 개의 다른 루프를 사용하여 두 개의 개별 컬렉션을 반복하는 경우: O(N+M) = `O(N)`
- 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우: `O(N²)`
- 두 개의 중첩 루프를 사용하여 두 개의 다른 컬렉션을 반복하는 경우: O(N*M) = `O(N²)`
- 컬렉션 정렬을 사용하는 경우: `O(NlogN)`

🪼 내 경우는 주로 반복문이 얼마나 겹쳐서 쓰이는 지를 가장 많이 봤었던 것 같다.

# 자료구조/정렬 알고리즘 별 시간 복잡도

https://www.bigocheatsheet.com/

위의 빅-오 복잡도 표도 위의 사이트에서 가져왔지만, 여기는 자료구조/알고리즘 별 시간 복잡도 표 또한 제공하고 있어 참고하기에 매우 좋다.

## 자료구조

![image.png](attachment:03133fd1-2625-4a9f-acfc-3671c3226f82:image.png)

## 정렬 알고리즘

![image.png](attachment:618bc8e6-eac8-46ec-b0f2-072ffff3f2f8:image.png)

# 참고 자료

[**면접을 위한 CS 전공지식 노트_주홍철**](https://product.kyobobook.co.kr/detail/S000001834833)

[**쉽게 배우는 알고리즘_문병로**](https://product.kyobobook.co.kr/detail/S000211830160)

[**C언어로 쉽게 풀어 쓴 자료구조_천인국, 공용해, 허상호**](https://product.kyobobook.co.kr/detail/S000001076349)

https://nado-coding.tistory.com/2

https://abruption.github.io/posts/Algorithm/

https://suyeon96.tistory.com/20

https://nado-coding.tistory.com/3

https://yoongrammer.tistory.com/78

https://servertrix.com/880

https://adjh54.tistory.com/186
일반적으로 이와 같이 나누는데, `선형 구조`와 `비선형 구조`를 주로 공부한다고 보면 된다.

## 선형 구조

데이터가 순서대로 정렬된 직선 연결 구조로 모든 요소가 하나의 경로로 연결되어 있다.

주로 순차적으로 데이터를 처리하는 데 사용

## 비선형 구조

데이터가 비연속적, 계층적이거나 복잡하게 연결된 구조

요소 간 여러 경로를 가짐

## ADT (추상 자료형, Abstract Data Type)

스택이나 큐 등을 보다보면 ADT라는 단어를 많이 볼 수 있다.

여기서 ADT는 추상 자료형으로, 데이터 타입과 그 데이터와 관계된 연산들을 수학적으로 정의만 한 것이다.

구현되어 있지 않고, 단순히 형태와 그 연산만 추상적으로 정의를 한 상태인 것이다.

Java에서 Interface를 사용하려면 이를 implement하여 구현체를 만들어야 하는데, 이와 비슷하다고 보면 된다.

# 알고리즘

> 문제를 해결하기 위한 절차나 방법
> 
- 어떤 작업을 수행하기 위한 과정을 애매하지 않게 기술한 것
- 저장된 데이터를 이용하여 문제를 해결하기 위한 절차나 방법을 의미

### 알고리즘의 조건

- 입력: 0개 이상의 입력이 존재해야 한다
- 출력: 1개 이상의 출력이 존재해야 한다
- 명백성: 각 명령어의 의미는 모호하지 않고 명확해야 한다
- 유한성: 한정된 수의 단계 후 반드시 종료가 되어야 한다
- 유효성: 각 명령어들은 실행 가능한 연산이어야 한다

### 알고리즘 선택

문제를 푸는 방식은 다양하다, 따라서 적용 가능한 알고리즘도 다양하다.

언제나 자원은 한정되어 있기 때문에 가능한 한 빠르게, 적은 리소스로 문제를 해결하는 것이 중요하다.

이러한 좋은 성능을 낼 수 있도록 최적의 알고리즘을 선택하는 것이 중요하다.

일반적으로 빅-오 표기법 등, `복잡도`라는 수치를 고려하여 알고리즘의 성능을 판단하고 선택하는 경우가 많다.

### 알고리즘 표현 방법

알고리즘은 절차나 방법을 묘사하는 것이다.
따라서 이에 대한 표현 방법이 다양하다.

- 자연어를 이용한 서술적 표현 방법
- 순서도를 이용한 도식화 표현 방법
    - 알고리즘 흐름 파악 용이
    - 복잡한 알고리즘 표현이 어려움
- 프로그래밍 언어를 이용한 구체화 방법
- 가상 코드(Pseudo-code)를 이용한 추상화 방법
    - 가상 코드를 이용한 알고리즘의 표현
    - 알고리즘 기술 언어(ADL; Algorithm Description Language)를 사용하여 프로그래밍 언어의 일반적인 형태와 비슷하게 알고리즘 표현
    - 직접 실행은 불가능 (특정 언어는 아니므로)
    - 원하는 프로그래밍 언어로 변환하기에 용이

# 자료구조와 알고리즘

알고리즘은 문제 해결을 위한 과정을 기술하고, 그 때 자료구조는 부품과도 같은 역할을 한다.

# 알고리즘 성능 분석 방법

효과적인 알고리즘을 얻기 위해 알고리즘의 성능을 분석하고 평가할 수 있어야 한다.
일반적으로 시간과 메모리 두 자원이 알고리즘의 효율성을 측정하는 척도가 된다.

기본적으로 복잡도라고 하는데, 알고리즘의 수행 시간을 분석한 결과는 `시간 복잡도(Time Complexity)`라고 하고, 메모리 사용량을 분석한 결과는 `공간 복잡도(Space Complexity)`라고 한다.

## 복잡도 (Complexity)

하드웨어 성능이 발전함에 따라 알고리즘이 돌아가는 메모리가 충분해지기도 하고,
시간 복잡도와 공간 복잡도는 반비례하는 경향이 있어,

보통 알고리즘의 성능을 파악할 때는 `시간 복잡도`를 위주로 판단한다.

### 공간 복잡도 (Space Complexity)

알고리즘 수행 과정에서 얼마나 많은 공간(메모리)를 차지하는가

- 알고리즘을 실행시키기 위해 필요한 공간은 두 가지로 나눌 수 있다
    - 고정 공간 (알고리즘과 무관한 공간)
        - 코드가 저장되는 공간
        - 알고리즘 실행을 위해 시스템이 필요로 하는 공간
    - 가변 공간 (알고리즘과 밀접한 공간)
        - 문제 해결을 위해 알고리즘이 필요로 하는 공간
        - 변수 저장 공간, 순환 스택 등

### 시간 복잡도 (Time Complexity)

**실행 명령어의 실행 횟수**

- 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수
- 알고리즘이 데이터를 처리하는 데 얼마나 걸리는가
    - 시간이라고 하지만, 실행 시간이 아닌 연산 횟수를 세는 이유는 모든 OS, IDE, 플랫폼에서 동일한 결과가 나오지 않기에…

# 점근 표기법

컴퓨터 알고리즘의 실행 시간은 실행 환경에 따라 다르게 측정된다.

따라서, 실행 환경을 동일하게 하는 것은 어렵기에 기본 연산(산술/제어 연산 등)의 실행 횟수로 성능을 분석한다.

함수가 복잡할수록 어느 알고리즘이 효율적인지 비교하는 것은 어려워지기 때문에, 함수를 단순화하기 위해 점근 표기법을 사용하여 표기하는 것이다.

함수의 증가율에 따른 다른 함수와 비교하는 것이 목표이기에 최고차항을 제외한 모든 항과 최고차항의 계수는 무시하여 O(n), O(logN), O(n²) 등으로 표시한다. (최고차항이 가장 영향력이 높기에)

## 점근 표기법의 종류

- 빅-오 표기법 (Ο): 최악의 경우
- 빅-오메가 표기법 (Ω): 최선의 경우
- 빅-세타 표기법 (Θ): 평균적인 경우

그 중에서 가장 많이 쓰이는 표기법은 `빅-오 표기법`이다.
최악의 경우에도 해당 알고리즘이 어떤 성능을 낼 수 있는지 가늠해볼 수 있기 때문.

## 빅-오 표기법 (Big-Ο Notation)

> 알고리즘의 성능이 최악의 경우라도 g(n)이상
> 

$$
f(n) = O(g(n))
$$

이때 g(n)을 함수 f(n)의 **점근적 상한**이라고 한다.

f(n)의 복잡도는 최악의 경우라도 g(n)보다 작거나 같다는 의미 (`f(n) ≤ g(n)`)

## 빅-오메가 표기법 (Big-Ω Notation)

> 알고리즘의 성능이 아무리 빨라도 g(n) 이하
> 

$$
f(n) = Ω(g(n))
$$

이때 g(n)을 함수 f(n)의 점근적 하한이라고 한다.

f(n)의 복잡도는 최선의 경우라도 g(n)보다 크거나 같다는 의미 (`f(n) ≥ g(n)`)

## 빅-세타 표기법 (Big-Θ Notation)

> 알고리즘의 성능이 g(n)의 상한과 하한에 포함(그 사이에 있다)
> 

$$
f(n) = Θ(g(n))
$$

이때 g(n)을 함수 f(n)의 **점근적 상한 및 하한**이라고 한다.

f(n)의 복잡도가 최선의 경우나 최악의 경우라도 g(n)의 범위 안에 있다는 의미 (대략 `f(n) = g(n)`)

# 시간 복잡도와 빅-오 표기법

그렇다면 일반적으로 빅-오 표기법을 사용하기에, 이를 기준으로 많이 사용되는 복잡도가 무엇이 있을 지 확인해보려고 한다.

이와 같이 빅-오 복잡도 그래프가 존재하는데, O(NlogN)부터 이제 슬슬 나쁜데~ 정도로 말하기 시작한다.

<img width="807" height="581" alt="image" src="https://github.com/user-attachments/assets/e82d5e15-5db3-40a0-aaf0-526a315f367e" />
빅-오 복잡도 표 (https://www.bigocheatsheet.com/)

아래 표에서 아래로 갈 수록 성능이 떨어지고, 시간 복잡도가 좋지 않은 알고리즘이라고 보면 된다.

| 표기 | 이름 | 시간 복잡도 | 설명 | 예시 |
| --- | --- | --- | --- | --- |
| O(1) | 상수 | 상수 시간 | 입력 크기와 상관 없이 일정한 실행 시간 | 충돌이 없는 해시 테이블 조회 |
| O(logN) | 로그 | 로그 시간 | 입력 크기가 증가함에 따라 실행 시간이 로그 함수의 형태로 증가 | 이진 탐색 |
| O(N) | 선형 | 선형 시간 | 입력 크기와 비례 | 선형 탐색, 단순 for 문 |
| O(NlogN) | 로그 선형 | 선형 로그 시간 | 입력 크기가 증가함에 따라 실행 시간이 로그 함수와 선형 함수의 곱의 형태로 증가 | 병합 정렬, 힙 정렬 |
| O(N²) | 이차 (2차) | 2차 시간 | 입력 크기의 제곱에 비례 | 선택 정렬, 버블 정렬, 이중 for 문 |
| O(2ⁿ) | 지수 | 지수 시간 | 입력 크기의 지수에 비례 | 부분 집합 |
| O(n!) | 계승 | 팩토리얼 시간 | 입력 크기의 팩토리얼에 비례 | 외판원 문제 |

### 내 코드에서 시간 복잡도를 구하는 팁

- 하나의 반복문을 사용하여 단일 요소 집합을 반복하는 경우: `O(N)`
- 컬렉션의 절반 이상을 반복하는 경우: O(N/2) = `O(N)`
- 두 개의 다른 루프를 사용하여 두 개의 개별 컬렉션을 반복하는 경우: O(N+M) = `O(N)`
- 두 개의 중첩 루프를 사용하여 단일 컬렉션을 반복하는 경우: `O(N²)`
- 두 개의 중첩 루프를 사용하여 두 개의 다른 컬렉션을 반복하는 경우: O(N*M) = `O(N²)`
- 컬렉션 정렬을 사용하는 경우: `O(NlogN)`

🪼 내 경우는 주로 반복문이 얼마나 겹쳐서 쓰이는 지를 가장 많이 봤었던 것 같다.

# 자료구조/정렬 알고리즘 별 시간 복잡도

https://www.bigocheatsheet.com/

위의 빅-오 복잡도 표도 위의 사이트에서 가져왔지만, 여기는 자료구조/알고리즘 별 시간 복잡도 표 또한 제공하고 있어 참고하기에 매우 좋다.

## 자료구조

<img width="867" height="457" alt="image" src="https://github.com/user-attachments/assets/ef3e9839-8d2c-4862-a313-4d95c5206caf" />

## 정렬 알고리즘

<img width="544" height="460" alt="image" src="https://github.com/user-attachments/assets/74ca2b57-b218-4d00-88a0-8e46fc379fe7" />

# 참고 자료

[**면접을 위한 CS 전공지식 노트_주홍철**](https://product.kyobobook.co.kr/detail/S000001834833)

[**쉽게 배우는 알고리즘_문병로**](https://product.kyobobook.co.kr/detail/S000211830160)

[**C언어로 쉽게 풀어 쓴 자료구조_천인국, 공용해, 허상호**](https://product.kyobobook.co.kr/detail/S000001076349)

https://nado-coding.tistory.com/2

https://abruption.github.io/posts/Algorithm/

https://suyeon96.tistory.com/20

https://nado-coding.tistory.com/3

https://yoongrammer.tistory.com/78

https://servertrix.com/880

https://adjh54.tistory.com/186
