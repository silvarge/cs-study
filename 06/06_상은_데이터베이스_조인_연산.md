조인은 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것을 말한다.

주로 관계형 데이터베이스에서 많이 사용하며(RDBMS의 핵심 기줄 중 하나),
MongoDB의 경우 lookup이라는 쿼리가 존재하지만 성능이 매우 떨어지니 웬만해서는 사용을 자제하자.
(성능을 대략 42% 정도 더 느리게 만들었다고 한다. _출처: https://velog.io/@byron1st/%EA%B0%84%EB%8B%A8%ED%95%9C-MongoDB-lookup-%EC%86%8D%EB%8F%84-%EC%B8%A1%EC%A0%95)

# 조인의 종류

<img width="778" height="371" alt="image" src="https://github.com/user-attachments/assets/de4486ea-0255-40f9-ac15-035c85d9b66c" />
해당 테이블을 기준으로 조인을 수행

## Inner Join (내부 조인)

두 테이블의 교집합

- 일반적으로 조인이라고 했을 때는 내부 조인을 의미
- 조건을 사용하여 두 테이블의 레코드를 결합
- 기준 테이블과 Join을 하고자 하는 테이블의 중복된 값을 보여줌

### 동등 조인

조인 구문에서 동등 비교(=)만을 사용하는 조인

```sql
select *
from employee e inner join dept d
on e.dept_id = d.id;
```

<img width="802" height="161" alt="image" src="https://github.com/user-attachments/assets/6bf6dffb-6439-44e3-88c9-6812687d2f59" />


### 비동등 조인

조인 구문에서 동등 비교 이외의 비교 연산자(<, > 등)도 사용하는 조인

```sql
select *
from employee e join dept d
on e.dept_id = d.id and e.dept_id < 3;
```

<img width="796" height="127" alt="image" src="https://github.com/user-attachments/assets/3a7e870a-1f39-44d9-8e44-2f02e926b9eb" />

### 자연 조인(Natural Join)

동등 조인의 한 유형, 동일한 이름의 컬럼은 하나만 

- 두 테이블에 같은 이름의 열이 있을 때만 동작
- 기준 테이블에서는 각 테이블의 id를 기준으로 비교, 동일한 값이 없어 아무것도 나오지 않음

```sql
select *
from employee natural join dept
```

## Outer Join

### Left (Outer) Join

좌측 테이블의 모든 데이터를 포함하는 결과 집합 생성

- 우측 테이블에 조인할 컬럼의 값이 없어도, 좌측 테이블의 모든 값이 나와야 하기에 null로 표기됨

```sql
select *
from employee left join dept
on employee.dept_id = dept.id;
```

<img width="891" height="191" alt="image" src="https://github.com/user-attachments/assets/f336dfa2-6cd2-45d7-956f-94f913c26db7" />

### Right (Outer) Join

우측 테이블의 모든 데이터를 포함하는 결과 집합 생성

- 좌측 테이블에 조인할 컬럼의 값이 없어도, 우측 테이블의 모든 값이 나와야 하기에 null로 표기됨

```sql
select *
from employee right join dept
on employee.dept_id = dept.id;
```

<img width="893" height="190" alt="image" src="https://github.com/user-attachments/assets/0b6caec3-9baf-4a4c-ac1a-03443c64cd33" />

### Full Outer Join (합집합 조인)

```sql
# MySQL의 경우 FULL OUTER JOIN을 지원하지 않아, UNION을 이용하여 합집합을 통해 만들어야 함
# PostgreSQL의 경우는 FULL OUTER JOIN 지원

(select * from employee left join dept on employee.dept_id = dept.id)
union 
(select * from employee right join dept on employee.dept_id = dept.id);
```

<img width="899" height="221" alt="image" src="https://github.com/user-attachments/assets/d3e525bc-0db8-4a13-b2d8-284c33bebf08" />

## Cross Join

조인되는 두 테이블에서 곱집합 반환

- 두 번째 테이블의 각 행과 첫 번째 테이블의 각 행이 한 번씩 결합된 열을 만든다.

```sql
# 일반적인 표현
select * from employee cross join dept;
# 암시적 표현
select * from employee, dept;
```

<img width="896" height="654" alt="image" src="https://github.com/user-attachments/assets/bceefed9-48ec-4fb8-8e0a-4556c9edd850" />

## Self Join

자기 자신을 조인하는 것

- 직원끼리 멘토-멘티 관계가 있을 경우, 직원 테이블을 멘티의 직원 번호와 직원 번호로 조인하여 멘티의 정보도 함께 전달하는 등의 방식
- 일반적으로 별칭을 주어 나열

```sql
select * from employee e1, employee e2 where e1.mentee_id = e2.id;
```

# 조인 알고리즘 (조인의 원리)

이러한 조인은 조인 알고리즘을 사용하여 쿼리를 최적화하고 실행 계획을 결정한다.

## Nested Loop Join (중첩 루프 조인)

- 가장 간단한 조인 알고리즘
- 바깥쪽 루프와 안쪽 루프로 두 테이블을 순차적으로 순회하면서 조인
    - 바깥쪽 루프: 기준 테이블을 선택
    - 안쪽 루프: 조인 조건에 해당하는 테이블을 선택
- 조인 조건에 해당하는 데이터를 찾으면, 바깥쪽 루프의 다음 행으로 넘어가며, 안쪽 루프는 처음부터 다시 시작
- 데이터 양이 적을 때는 성능이 좋지만, 데이터 양이 많을 경우 비효율적일 수 있다.

## Hash Join (해시 조인)

일단 작은 테이블을 스캔하고, 결합 키에 해시함수를 적용해서 해시 값으로 변환하여 새로운 해시 테이블을 만들어 이를 기반으로 조인

- 큰 테이블과 작은 테이블 사이에서 조인을 수행하는 데 효과적인 알고리즘
- 작은 테이블을 해시 함수를 사용하여 해시 테이블로 만듦
- 큰 테이블의 각 행을 해시 함수에 적용하여 해시 테이블에서 조인할 데이터 검색
- 작은 테이블과 큰 테이블의 크기가 비슷하면 좋은 성능을 발휘하지만, 작은 테이블이 매우 작거나 클 때에는 (차이가 많이 나는 경우) 효율이 떨어질 수 있다.
- 동등 조인에서만 사용 가능

## Sort Merge Join (정렬 병합 조인)

결합 대상 테이블들을 각각 결합 키로 정렬하고, 이 둘을 모두 워킹 메모리에 저장

- sort와 merge의 phase가 존재
    - sort: 조인에 사용할 키에 대해 양쪽 테이블을 정렬
    - merge: 두 개의 sorted table에 대해 cursor를 설정하고 매칭되는 튜플을 저장

# 참고자료

https://adjh54.tistory.com/155#1.%20%EB%82%B4%EB%B6%80%20%EC%A1%B0%EC%9D%B8(INNER%20JOIN)-1-2

https://yuna-story.tistory.com/164

https://s-y-130.tistory.com/143

https://developbear.tistory.com/126

https://simple-coding-place.tistory.com/40 ← 이걸로 더 공부해야 할듯? 조인 알고리즘은 따로 하는게… 더 맞는듯
