# 인덱스

## 1️⃣ 인덱스란?

- **데이터를 빠르게 탐색하기 위한 장치**
- 조회(SELECT) 성능뿐 아니라, 수정(UPDATE), 삭제(DELETE) 성능에도 영향
- DBMS는 인덱스를 항상 최신 정렬 상태로 유지해야 한다.
    
    👉 따라서 **INSERT, UPDATE, DELETE** 시 추가 연산이 발생한다.
    
    - **INSERT**: 새로운 데이터에 대한 인덱스 추가
    - **DELETE**: 삭제된 데이터에 대해 “사용하지 않음” 작업 진행
    - **UPDATE**: 기존 인덱스를 무효화하고 새로운 인덱스 추가


## 2️⃣ 인덱스 장단점

### ✅ 장점

- 조회 속도 향상 → 시스템 부하 감소

### ❌ 단점

- 인덱스를 유지·관리하기 위한 **추가 저장공간(DB의 약 10%)** 필요
- INSERT/UPDATE/DELETE 연산 시 성능 저하 가능
- 잘못 설계된 인덱스는 성능을 오히려 떨어뜨릴 수 있음
    - DELETE/UPDATE가 빈번하면 “사용하지 않음” 인덱스가 쌓여 인덱스 크기만 커짐 → 성능 저하

## 3️⃣ 인덱스를 사용하면 좋은 경우

- 테이블의 데이터 규모가 크다
- `INSERT`, `UPDATE`, `DELETE`가 자주 발생하지 않는다
- `WHERE`, `JOIN`, `ORDER BY`에 자주 사용되는 컬럼
- 데이터 **중복도가 낮은 컬럼**

👉 사용하지 않는 인덱스는 반드시 제거해야 한다.


## 4️⃣ 인덱스 구조

### 🔹 B-Tree 인덱스

- MySQL 기본 인덱스 구조
- **루트 → 브랜치 → 리프 노드** 형태의 균형 트리
- 리프 노드에 인덱스 + 데이터 저장, 나머지는 데이터를 위한 인덱스(키)만 저장
- 리프 노드끼리는 Linked List로 연결되어 순차 검색에 유리
- **부등호 연산 (`>`, `<`)** 이 많은 조회에 적합
- 데이터 노드 크기는 인덱스노드의 크기와 같지 않아도 됨

### 🔹 해시 테이블

- Key-Value 형태: key로 고유 인덱스 생성하여 해당 값 꺼내오는 구조, (데이터=컬럼의 값, 데이터의 위치→ 컬럼의 값으로 생성된 해시를 통해 인덱스 구현)
- 빠른 검색이 필요할 때
- 해시 함수로 특정 값의 저장 위치를 바로 탐색
- **등호(`=`) 연산**에 최적화
- 범위 검색에는 부적합 → 일반적으로 B-Tree 인덱스가 더 많이 쓰임
<img width="525" height="387" alt="스크린샷 2025-09-18 오후 1 48 21" src="https://github.com/user-attachments/assets/bc085779-bc23-48d7-8bd3-94f6b2a4e164" />

## 5️⃣ 인덱스 효율성 (대수 확장성)

- B-Tree는 **균형잡힌 트리 구조**라 효율적
- **대수 확장성**: 트리 깊이는 리프노드 수에 비해 느리게 증가하지만, 인덱스 항목 수는 기하급수적으로 증가
    - 트리 깊이가 1 증가할 때마다 인덱스 항목은 최대 4배 증가


## 6️⃣ MySQL 인덱스

- **클러스터 인덱스 (Clustered Index)**
    - PK 기반으로 레코드의 **물리적 저장 위치**를 결정
    - 한 테이블에 하나만 존재
    - InnoDB에서 PK가 클러스터 인덱스 (없으면 내부적으로 자동 생성)
    - **장점**: PK 검색이 매우 빠름, 순차 조회시 효율적
    - **단점**: PK 변경 시 성능 저하 (DELETE + INSERT 필요), INSERT 시 저장 위치 탐색 비용 발생
- 세컨더리 인덱스: `create index..명령어`. 보조인덱스. 여러 필드 값을 기반으로 쿼리를 많이 보낼때 생성해야하는 인덱스.

👉 결국, **읽기 성능 최적화**를 위해 쓰기 성능을 일부 희생한 구조


## 7️⃣ MongoDB 인덱스 최적화 기법

1. **인덱스는 비용이다**
    - 인덱스 탐색 후 컬렉션 탐색 → 두 번 읽기 필요
    - 컬렉션 수정 시 인덱스도 함께 수정됨
    - 따라서 모든 컬럼에 무작정 인덱스 추가 ❌
2. **테스팅 필수**
    - 서비스마다 쿼리 특성이 다름
    - `explain()` (MongoDB) / `EXPLAIN` (MySQL) 활용해 성능 확인
3. **복합 인덱스 생성 순서**
    1. `=` 연산 컬럼 먼저
    2. 정렬에 사용하는 컬럼
    3. 범위 검색 (`<`, `>`) 컬럼
    4. 카디널리티(유니크한 값이 많은 컬럼) 높은 순
