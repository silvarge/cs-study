# 인덱스(Index)란?

> 검색 속도를 향상시키기 위해 사용하는 자료 구조
> 

> 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
> 
> 
> 데이터와 데이터의 위치를 포함한 자료구조를 생성하여 빠르게 조회할 수 있도록 돕고 있다.
> 

<img width="700" height="429" alt="image" src="https://github.com/user-attachments/assets/594d475c-7f80-4edd-8c0c-bf3a9d5f1dab" />

만약 인덱스를 사용하지 않은 칼럼을 조회해야 하는 상황이라면, 전체를 탐색하는 `Full Scan`을 수행해야 함 → 처리 속도의 저하

### 어떤 성능이 향상되나요?

- **검색 속도**의 향상 (SELECT)
- UPDATE 및 DELETE의 성능 향상 → 삭제 및 갱신을 수행할 때에는 그에 대한 대상을 조회해야만 작업을 수행할 수 있기 때문
⇒ 조회가 전제되는 작업

#### 📋

PRIMARY KEY - 기본 키에 자동으로 생성

UNIQUE INDEX - 중복을 방지하며 검색 속도 향상

COVERING INDEX - 조회 성능을 극대화

⇒ 자주 검색하는 컬럼에는 직접 인덱스를 생성하기

⇒ 커버링 인덱스를 활용하면 성능을 극대화 시킬 수 있다!

## 인덱스는 왜 사용하나요?

> 검색을 빠르게 하기 위해서!
> 

일반적으로, 쿼리 요청 중 가장 많이 요청되는 것은 `READ`이다. 얼마나 많으면 떠도는 말 중 쿼리 요청의 80%는 READ라는 말도 있을까?

정확한 정보는 아니지만, 이러한 말이 떠돌아 다닌다는 점에서 쿼리 요청 중 `READ` 비중이 매우 높다는 점은 많은 사람들이 공감하고 있는 내용이라고 볼 수 있다.

### 조건 검색(WHERE)의 효율성

인덱스 테이블은 데이터들이 정렬되어 저장되어 있기에 조건에 맞는 데이터들을 바르게 찾아낼 수 있다.

### 정렬(ORDER BY)의 효율성

`ORDER BY`에 의한 정렬 과정을 피할 수 있다는 점.

→ 정렬과 동시에 일차적으로 메모리에서 정렬이 이루어지고, 메모리보다 큰 작업이 필요하다면 디스크 I/O도 추가적으로 발생되기 때문.

인덱스를 사용하면 전반적인 자원의 소모를 하지 않아도 되기에 가져오기만 하면 된다는 점에서 좋다!

### MIN, MAX의 효율적인 처리 가능

얘도 데이터가 정렬되어 있을 때가 가장 효율이 좋다!

이미 정렬되어 있기에 레코드 시작 값 혹은 끝 값 한 건씩만 가져오면 되기에 모두 뒤져서 비교해서 응답하는 것보다 훨씬 효율적으로 찾을 수 있다.

## 접근 경로로서의 인덱스


> 인덱스는 필드에 접근하는 경로
> 
- Single-Level 인덱스는 데이터 레코드를 찾는 효과적인 보조물
- 1개의 인덱스 파일은 <필드 값, 레코드의 포인터>로 구성
- 인덱스 파일은 Data file에 비해 상대적으로 작은 디스크 블록을 점유하는데,
Entry가 작기 때문
- 인덱스는 조밀한 정도에 따라 Dense index/Sparse index로 나누어질 수 있다.

## 인덱스는 어떻게 동작하는가?

- 생성
    - 인덱스 테이블 생성 시 생성하고 싶은 인덱스 컬럼을 지정한다
    - 특정 컬럼에 대한 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적인 주소와 함게 저장된다.
- 조회
    1. 인덱스 테이블에서 WHERE에 포함된 값을 찾음
    2. 해당 값의 table_id[PK]를 가져옴
    3. 가져온 table_id[PK] 값으로 원본 테이블에서 값을 조회해 옴
    

> 인덱스가 생성되면 해당 컬럼에 대한 WHERE 조건문을 사용하여 쿼리를 날릴 때 `옵티마이저에 의해 판단`되어 생성된 인덱스를 탈 수 있게 된다.
> 
> 
> **인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 방식**으로 동작하여 검색 속도의 향상을 가져올 수 있다.
> 

#### 💡옵티마이저(Optimizer)란?

SQL을 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부의 핵심 엔진

## 인덱스의 장단점

### 장점

- 테이블을 조회하는 속도와 그에 따른 성능 향상
- 전반적인 시스템의 부하 감소
- 테이블의 전체 데이터 중에서 **10-15% 이하의 데이터를 처리하는 경우**에만 효율적

### 단점

- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요
(추가적으로 마련하는 자료구조이기에)
- 인덱스를 관리하기 위해 추가 작업이 필요
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과 발생 가능성
    - CREATE/DELETE/UPDATE가 빈번한 속성이 인덱스를 걸게 되면 인덱스의 크기가 비대해져 성능이 오히려 저하되는 역효과 발생
        - DELETE/UPDATE의 경우, 기존 인덱스 데이터를 삭제하지 않고 ‘사용하지 않음’ 처리를 하기 때문
        
        ⇒ 사용안함 표시로 (페이지 분할로 인한)페이지 낭비 및 인덱스 조각화가 심해짐
        
        ⇒ 실제 데이터는 10만 건이지만, 인덱스는 100만 건이 넘어가는 배보다 배꼽이 큰 상황을 맞이할 수 있음
        
    - 사용하지 않는 인덱스가 적용되었다면 불필요한 처리량 증가
- 정렬된 상태를 계속 유지 시켜줘야 한다는 점을 고려해야 한다

# 인덱스의 분류

인덱스는 기존 DB 테이블과 달리 데이터 중복성을 가질 수 있다. 그래서 다양한 종류의 인덱스 형태가 존재하는데, 내가 사용하는 목적에 따라 적절하게 사용하는 것이 좋다.

### 파일 조직에 따른 인덱스 분류 (클러스터링 인덱스와 논-클러스터링 인덱스)

> 물리적으로 인접한 장소에 저장되어 있는 데이터(비슷한 값)들을 동시에 조회하는 경우가 많다는 점에서 착안
> 
- 클러스터링 인덱스 (Clustered Index)
    
    > 실제 데이터와 같은 무리의 인덱스 (ex. 실제 데이터가 정렬된 사전)
    > 
    - 실제 데이터 자체가 정렬되어 있음
    - 테이블 당 한 개만 생성할 수 있다
    - 리프 페이지가 데이터 페이지(실제 데이터가 저장된 곳)
    - 아래의 제약조건 시 자동 생성
        - PK (우선순위를 가짐)
        - unique + not null
- 논-클러스터링 인덱스 (Non-Clustered Index)
    
    > 실제 데이터와 다른 무리의 별도의 인덱스 (ex. 별도의 찾아보기 페이지)
    > 
    - 실제 데이터 페이지는 그대로
    - 별도의 인덱스 페이지 생성 → 추가적인 공간이 필요하다
    - 테이블당 여러 개 존재
    - 리프 페이지에 실제 데이터 페이지의 주소를 담고 있음
        - OR 클러스터링 인덱스가 적용된 컬럼의 실제 값
    - unique 제약조건 적용시 자동 생성
    - 직접 index 생성시 논-클러스터링 인덱스 생성

### 키에 따른 인덱스 분류 (Primary Index VS Secondary Index)

- 기본 인덱스
    - PK에 대해서 생성된 Index를 의미
    - 테이블 당 하나의 Primary Index만 존재할 수 있음
    - 기본적으로 클러스터드 인덱스(집중 인덱스)를 생성
        
        ⇒ 키의 순서가 레코드의 순서를 결정 지음 (실제 데이터를 정렬시키기 때문)
        
- 보조 인덱스
    - PK가 아닌 다른 칼럼에 대해서 생성된 Index를 의미
    - 테이블 당 여러 개의 Secondary Index를 생성할 수 있음
    - 기본 인덱스 이외의 인덱스
    - 키의 순서가 레코드의 순서를 의미하진 않음

### 데이터 범위에 따른 인덱스 분류

- 밀집 인덱스 (Dense Index)
    - 데이터 레코드 각각에 대해 하나의 인덱스 엔트리가 만들어진 인덱스
- 희소 인덱스 (Sparse Index)
    - 레코드 그룹 또는 데이터 블록에 대해 하나의 엔트리가 만들어지는 인덱스

## QNA - 다수의 인덱스

인덱스는 클러스터링 인덱스/논-클러스터링 인덱스로 분류할 수 있다.

🤔. 하지만 id라는 PK 컬럼을 통해 클러스터링 인덱스를, name 컬럼에 논-클러스터링 인덱스를 적용한다면 어떻게 만들어질까?

😝. 논-클러스터링 인덱스는 데이터 페이지의 주소를 담는다고 했지만, 이 때에는 id 컬럼의 값(클러스터링 인덱스)을 넣고 있다.

🤔. 근데 논-클러스터링 인덱스만 있을 때는 주솟값을 넣는데, 왜 굳이 따로따로 나눠도 되는 거 아닌가?

😝. 새로운 데이터를 추가하고, 정렬하는 과정(페이지 분할 등)에서 데이터의 주소값이 변경되는 상황이 발생할 수 있다. 논-클러스터링 인덱스가 주소값을 저장하고 있는 상황에서는 데이터 추가 등의 연산 시 인덱스 페이지의 주소를 계속 수정해야 하는 상황이 발생할 수 있다.
PK가 직접 변경되지 않는 한 인덱스 페이지에 영향을 주지 않도록 구성할 수 있도록 `클러스링 인덱스가 적용된 컬럼의 실제 값`을 넣는다.

# 인덱스를 사용하면 좋은 경우


- 규모가 작지 않은 테이블
- INSERT, UPDATE,, DELETE가 자주 발생하지 않는 컬럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 컬럼
- 데이터의 중복도가 낮은 컬럼
- 기타

## 어떤 컬럼에 인덱스를 설정하는 것이 좋을까?


- 일반적으로 한 테이블 당 3-5개 정도의 인덱스가 적당하다.
- 카디널리티, 선택도, 활용도, 중복도를 잘 고려하면 효율적으로 인덱스를 설정할 수 있다.

하지만 어떤 데이터를 다루는지, 그 데이터가 어떤 특징을 가지고 있는 지를 추가적으로 고려해야 한다는 점! 절대적으로 아래 수치만을 통해 판단할 수 있는 것은 아니다.

### 카디널리티

> 카디널리티가 높을수록 인덱스 설정에 좋은 컬럼이다.
> 
> 
> (한 컬럼이 갖고 있는 값의 중복도가 낮을 수록 좋다.)
> 

### 선택도 (Selectivity)

> 선택도가 낮을 수록 인덱스 설정에 좋은 컬럼이다.
> 
> 
> 일반적으로 5-10%가 적당하다.
> 

#### 💡선택도란?

데이터에서 특정 값을 얼마나 잘 선택할 수 있는지에 대한 지표,

특정 값으로 조건을 걸었을 때 필터링 되는 비율

(특정 필드값을 지정했을 때 선택되는 레코드 수를 테이블 전체의 레코드 수로 나눈 비율)

`= 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100`

`= 컬럼 값들의 평균 row 수 / 테이블의 총 row 수 * 100` 


### 활용도

> 활용도가 높을 수록 인덱스 설정에 좋은 컬럼이다.
> 

해당 컬럼이 실제 작업에서 얼마나 활용되는 지에 대한 값이다.

수동 쿼리 조회, 로직과 서비스에서 쿼리를 날릴 때 WHERE 절에서 자주 활용되는지를 통해 판단할 수 있다.

### 중복도

> 중복도가 없을 수록 인덱스 설정에 좋은 컬럼이다.
> 

#### 💡중복도란?

중복되는 인덱스가 존재하는 지에 대한 값.

동일한 인덱스가 중복 생성 되었는지에 대한 값

인덱스 성능에 대한 고려 없이 마구잡이로 설정하거나, 다른 부서/다른 작업자의 분리된 요청으로 같은 컬럼에 대해 인덱스가 중복으로 생성된 경우를 볼 수 있다.

| 항목 | 적합 기준 | 설명 |
| --- | --- | --- |
| 카디널리티 | 높을 수록 적합 | 컬럼 내의 데이터에 대한 중복도가 낮을 수록 선정하기에 좋다.<br>고유 값이 많을 수록 필터링 효과가 크다. |
| 선택도 | 낮을 수록 적합 (5-10% 적정) | 특정 값으로 조건을 걸었을 때, 필터링되는 비율이 낮은 컬럼일수록 좋다.<br>특정 조건에서 적은 ROW가 선택될 수 있도록 하는 것이 좋다. |
| 활용도 | 높을 수록 적합 | 실제 작업에서 많이 활용되는 컬럼일수록 좋다.<br>자주 쓰일수록 성능에 영향이 크기 때문. |
| 중복도 | 없을 수록 적합 | 인덱스 테이블의 구성에서 중복되지 않는 컬럼일수록 좋다.<br>불필요한 인덱스 중복은 피해야 하기 때문. |

#### 👉 Index 선정 기준

1. 항상 = 로 비교되는 컬럼 → **카디널리티가 높은 컬럼**
2. **중복되는 데이터가 최소한**인(분포도가 좋은) 컬럼 → 선택도가 높다
3. INSERT/UPDATE/DELETE가 자주 발생하지 않는 컬럼 → 오히려 인덱스가 좋지 않을 수 있음
4. 조건절에 자주 등장하는 컬럼 → 활용도가 높다
5. ORDER BY 절에서 자주 사용되는 컬럼 → 정렬에 사용된다 (인덱스는 정렬된 자료구조)
6. JOIN 조건으로 자주 사용되는 컬럼 → 활용됴가 높다
7. 규모가 작지 않은 테이블

# 인덱스의 자료구조

## 해시 테이블

> (Key, Value) 형태로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용
> 

Key 값을 이용해 고유한 Index 값을 생성하고, 해당 Index에 데이터를 저장하거나 Index에 저장된 값을 꺼내오는 구조

<img width="315" height="230" alt="image" src="https://github.com/user-attachments/assets/cd554d78-e9f7-48cd-adc3-18596095edf5" />

해시 테이블의 탐색 시간복잡도는 O(1)이며, 매우 빠른 검색을 지원한다.

하지만 등호 연산에만 특화되었기 때문에, 해시 테이블이 사용되는 경우는 **매우 제한적**

부등호 연산이 자주 사용되는 데이터베이스 검색에 해시 테이블은 적합하지 않음.

⇒ 따라서 인덱스 저장을 위한 자료구조로는 주로 B+Tree가 많이 사용됨

## B+트리

> DB의 인덱스를 위해 자식 노드가 2개 이상인 B Tree를 개선한 자료구조
> 

리프 노드(데이터 노드)만 인덱스와 함께 데이터(Value)를 저장하고, 나머지 노드(인덱스 노드) 들은 데이터를 위한 인덱스(Key)만 가짐

리프 노드들은 Linked List로 연결되어 있음

데이터 노드의 크기는 인덱스 노드의 크기와 같지 않아도 됨

<img width="580" height="241" alt="image" src="https://github.com/user-attachments/assets/c51c0f47-8008-4ec8-9995-c000a813cb1c" />

- 실제 데이터가 저장된 리프노드 (Leaf Nodes)
- 리프노드까지의 경로 역할을 하는 논리프노드 (Non-leaf Nodes)
- 경로의 출발점이 되는 루트 노드 (Root Node)
    
    ⇒ 루트 노드에서 어떤 리프 노드에 이르는 한 개의 경로만 검색하면 되므로, 매우 효율적이다.
    

이러한 구조로 인하여 B+ 트리 인덱스는 등가 비교 및 범위 검색에도 사용할 수 있다.

하지만, 범위 검색 중 LIKE 검색의 경우, 와일드 카드는 전방 일치여야 인덱스 효과를 얻을 수 있음
(문자열이 사전 순서대로 정렬되어 있기 때문에, 전방 일치가 아닌 LIKE 검색은 물리적으로 어려움)


# 인덱스 사용 시 주의사항

### 잘 활용되지 않는 인덱스는 과감히 제거

- WHERE 절에 사용되더라도 자주 사용해야 가치가 있다
- 불필요한 인덱스는 성능 저하의 원인이 될 수 있다

### 데이터 중복도가 높은 컬럼은 인덱스 효과가 적다

### 자주 사용되더라도 INSERT/UPDATE/DELETE가 자주 일어나는지 고려해야 한다

- 일반적인 웹 서비스와 같은 온라인 트랜잭션 환경에서 쓰기와 읽기 비율은 2:8 또는 1:9이다
- 조금 느린 쓰기를 감수하고 빠른 읽기를 선택하는 것도 하나의 방법 (Trade Off)

# 참고자료

https://mangkyu.tistory.com/96

https://mangkyu.tistory.com/286

https://ggop-n.tistory.com/76

https://brunch.co.kr/@skeks463/25

https://www.youtube.com/watch?v=85Zg0HUv_Eo

https://mongyang.tistory.com/75

https://www.fun-coding.org/post/mysql_advanced5.html#gsc.tab=0
