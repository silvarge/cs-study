> 이 포스팅은 주홍철 저 '면접을 위한 CS 전공지식 노트' 4.5장을 토대로 작성되었습니다.  
>   

## 인덱스의 필요성

**인덱스**는 데이터를 빠르게 검색하기 위한 도구입니다.

책에서 원하는 내용을 찾을 때, 모든 페이지를 차례차례 넘기면서 찾는 것보다

목차에서 "ㅇㅇ: 90쪽"와 같은 색인(index)을 통해 해당 페이지부터 찾는 것이 빠를 겁니다.

이처럼 데이터베이스 테이블 내에도 인덱스를 설정하여

검색 대상 행(row)의 범위를 줄일 수 있고, 원하는 데이터를 보다 빠르게 찾을 수 있습니다.

---

## 인덱스의 장단점

#### 💡 장점

-   **빠른 조회 속도:** 데이터를 빠르게 검색할 수 있어 조회(SELECT) 성능이 크게 향상됩니다.
-   **정렬 및 그룹화 성능 향상:** ORDER BY나 GROUP BY 같은 작업의 성능도 개선됩니다.

#### ⚠️ 단점

-   **추가 저장 공간 필요:** 인덱스 자체도 데이터이기 때문에 별도의 저장 공간을 차지합니다.
-   **쓰기 성능 저하:** 데이터 추가, 수정, 삭제(INSERT, UPDATE, DELETE) 작업이 발생할 때, 테이블의 데이터뿐만 아니라 인덱스도 함께 갱신해야 하므로 쓰기 성능이 느려집니다.

---

## 인덱스 자료구조: B-Tree

보편적으로 인덱스는 B-트리 구조로 구성됩니다.

B-트리는 균형 트리(Balanced Tree)로, 대량의 데이터를 효율적으로 검색, 삽입, 삭제하도록 설계됐습니다.

균형 잡혔다는 것은, 모든 리프 노드(가장 끝에 있는 노드)가 동일한 깊이를 가진다는 뜻입니다.

이 덕분에 어떤 데이터를 찾더라도 최악의 경우에도 검색 시간이 일정하여, 매우 안정적입니다.

또한 B-트리 구조에서 모든 노드 내 데이터는 정렬되어 있습니다. 노드 내에서 원하는 데이터를 빠르게 찾을 수 있습니다.

<img width="963" height="253" alt="image" src="https://github.com/user-attachments/assets/338af3da-769b-4695-98c8-a414b81ba7c8" />

이 구조에서 노드 자체가 인덱스가 됩니다.

예를 들어, 루트 노드에서 \[100, 155, 226\]은 실제 데이터를 담고 있는 것이 아니라 데이터를 찾아가는 색인 역할을 합니다.

-   100보다 작은 값은 왼쪽 브랜치 노드로
-   100과 155 사이의 값은 가운데 브랜치 노드로
-   155와 226 사이의 값은 그 다음 브랜치 노드로
-   226보다 큰 값은 가장 오른쪽 브랜치 노드로 이는 **길잡이** 역할을 합니다.

이처럼 대용량 데이터에 대해 효율적으로 관리하고 검색할 수 있어 B-Tree 구조를 인덱스로 사용합니다.

-   얕은 트리 깊이: 이진 트리가 아니라 각 노드는 많은 수의 자식 노드를 가져 트리의 깊이가 얇습니다.
    -   얇은 깊이 덕분에 디스크에서 읽어와야 하는 노드의 수가 적어 디스크 I/O 횟수가 적고 속도가 빠릅니다.
-   균형성: 모든 리프 노드가 동일한 깊이를 가져 최악의 경우에도 시간복잡도가 O(logN)으로 안정적인 속도를 보장합니다.
-   효율적인 검색: 노드 내 키들이 정렬되어 있어 빠르게 찾을 수 있습니다.

---

## 인덱스 타입 종류

인덱스는 크게 클러스터 인덱스(Primary Index)와 세컨더리 인덱스(Secondary Index)로 나눠집니다.

**클러스터 인덱스**는 테이블의 실제 물리적 정렬 순서와 일치하는 인덱스입니다. 즉, 인덱스 자체가 데이터가 저장된 순서를 결정합니다. 처음부터 정렬이 되어 있는 영어 사전과 비슷합니다.

**세컨더리 인덱스**는 데이터의 물리적 정렬 순서와는 무관하게 만들어지는 인덱스입니다. 클러스터 인덱스와 달리 데이터를 정렬시키지 않으며, 인덱스 구조 안에 실제 데이터가 아닌 데이터 레코드를 찾아가는 주소(포인터)를 가지고 있습니다. 책 뒤의 찾아보기의 개념과 비슷합니다.

|   | 클러스터 인덱스 | 세컨더리 인덱스 |
| --- | --- | --- |
| 속도 | 빠르다 | 느리다 |
| 사용 메모리 | 적다 | 많다 |
| 인덱스 | 인덱스가 주요 데이터 | 인덱스가 데이터의 사본(Copy) |
| 개수 | 한 테이블에 한 개 | 한 테이블에 여러 개(최대 약 250개) |
| 리프 노드 | 리프 노드 자체가 데이터 | 리프 노드는 데이터가 저장되는 위치 |
| 저장값 | 데이터를 저장한 블록의 포인터 | 값과 데이터의 위치를 가리키는 포인터 |
| 정렬 | 인덱스 순서와 물리적 순서가 일치 | 인덱스 순서와 물리적 순서가 불일치 |

이렇게만 보면 세컨더리 인덱스 왜 쓰나 싶은데,

클러스터 인덱스는 테이블당 하나만 만들 수 있다는 결정적인 한계가 있습니다.

사용자는 다양한 조건으로 데이터를 조회하기 때문에, 단 하나의 정렬 기준으로는 모든 검색 요구를 만족시킬 수 없습니다.

세컨더리 인덱스는 바로 이 문제를 해결해 줍니다. 예를 들어, \`직원\` 테이블이 \`직원\_번호\`라는 프라이머리 키로 클러스터링되어 있다고 가정해 볼게요.

-   **이름으로 검색하는 경우:** "김철수"라는 직원을 찾을 때 \`직원\_번호\` 순서로 정렬된 테이블을 처음부터 끝까지 스캔해야 합니다.
-   **부서명으로 검색하는 경우:** "개발부"에 속한 모든 직원을 찾을 때도 마찬가지입니다.

이런 경우 이름이나 부서명 필드에 세컨더리 인덱스를 생성하면, 클러스터 인덱스에 비해 속도는 조금 느리더라도 **검색 성능을 크게 향상**시킬 수 있습니다.

---

## 인덱스 설계

인덱스가 검색 속도를 빠르게 한다고 늘 인덱스를 사용해야 하는 것은 아닙니다.

사용해야 할 때와 사용하면 안 될 때를 구분해야 합니다.

### ✅ 인덱스를 사용해야 하는 경우

인덱스는 조회(SELECT) 성능을 최적화하는 데 목적이 있습니다.

1.  **WHERE 절에 자주 사용되는 컬럼:** 특정 조건을 걸어 데이터를 자주 검색하는 컬럼에 인덱스를 만듭니다. 
2.  **JOIN의 연결고리가 되는 컬럼:** 여러 테이블을 JOIN할 때 사용하는 외래 키 컬럼에 인덱스를 생성하면 연결된 테이블 간의 조회 속도가 빨라집니다.
3.  **ORDER BY나 GROUP BY가 자주 사용되는 컬럼:** 데이터를 정렬하거나 그룹화하는 작업이 잦다면, 인덱스가 미리 정렬된 데이터를 제공하여 성능을 크게 향상시킵니다.
4.  **카디널리티(Cardinality)가 높은 컬럼:** 데이터의 중복도가 낮은 컬럼일수록 인덱스의 효율이 좋습니다. 예를 들어, 주민등록번호나 이메일처럼 고유한 값이 많은 컬럼이 인덱스 효과를 극대화합니다.

> 카디널리티란?  
> 유니크한 값의 정도를 말합니다. 예를 들어 age와 email 컬럼 중 카디널리티가 높은 것은 email입니다.

### ⚠️ 인덱스를 사용하면 안 되는 경우

인덱스는 조회 성능을 높이는 대신 데이터 삽입, 수정, 삭제(INSERT, UPDATE, DELETE) 성능을 저하시킵니다. 따라서 쓰기 작업이 더 중요한 경우 인덱스 사용을 지양해야 합니다.

1.  **데이터 변경(수정/삭제/삽입)이 잦은 컬럼:** 데이터가 자주 바뀌는 컬럼에 인덱스를 만들면, 인덱스도 함께 갱신해야 하므로 오버헤드가 커집니다. 예를 들어, \`last\_login\` 같은 자주 변하는 컬럼은 인덱스에 적합하지 않습니다.
2.  **카디널리티(Cardinality)가 낮은 컬럼:** 데이터 중복이 심한 컬럼(예: 성별, 학년, 상태 코드 등)에 인덱스를 만들면, 인덱스가 오히려 풀 테이블 스캔보다 비효율적일 수 있습니다. 인덱스를 탐색하는 비용이 모든 데이터를 순차적으로 읽는 비용보다 더 커질 수 있기 때문입니다.
3.  **작은 규모의 테이블:** 데이터 양이 적은 테이블은 인덱스 유무와 관계없이 풀 테이블 스캔이 빠를 수 있습니다. 이 경우 인덱스는더 큰 낭비가 됩니다.

---

참고자료

[\[MySQL\] B-Tree로 인덱스(Index)에 대해 쉽고 완벽하게 이해하기](https://mangkyu.tistory.com/286)  
[\[DB\] 데이터베이스 인덱스(index) 개념 정리](https://ittrue.tistory.com/331)

[\[MYSQL\] 📚 인덱스(index) 핵심 설계 & 사용 문법 💯 총정리](https://inpa.tistory.com/entry/MYSQL-%F0%9F%93%9A-%EC%9D%B8%EB%8D%B1%EC%8A%A4index-%ED%95%B5%EC%8B%AC-%EC%84%A4%EA%B3%84-%EC%82%AC%EC%9A%A9-%EB%AC%B8%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC#%EC%9D%B8%EB%8D%B1%EC%8A%A4_%ED%83%80%EC%9E%85_%EC%A2%85%EB%A5%98)
