> 이 포스팅은 주홍철 저 '면접을 위한 CS 전공지식 노트' 4.6, 4.7장을 토대로 작성되었습니다.  

## 조인(JOIN)

**조인(join)**이란

하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과 집합을 만드는 연산을 말합니다.

<img width="1027" height="519" alt="image" src="https://github.com/user-attachments/assets/0c94cd36-fe1f-4011-9ebb-780fac017834" />

일반적으로 FROM 절 뒤에 나오는 테이블이 왼쪽 테이블이고,

JOIN 키워드 뒤에 나오는 테이블이 오른쪽 테이블입니다.

---

## SQL 조인 종류

### Inner Join: 내부 조인

<img width="368" height="222" alt="image" src="https://github.com/user-attachments/assets/9e125da5-1e2e-4f84-993e-9abc939c0879" />

-   두 테이블 간의 교집합
-   두 테이블에서 ON 절의 조건이 일치하는 레코드만 결과에 포함합니다. 어느 한쪽 테이블에만 있는 데이터는 제외합니다.
-   예시: orders 테이블과 customers 테이블을 조인하여, 주문한 적이 있는 고객 정보만 가져오기

```
SELECT * FROM orders
INNER JOIN customers
ON orders.customer_id = customers.id;
```

---

### Left Join: 왼쪽 조인

<img width="197" height="160" alt="image" src="https://github.com/user-attachments/assets/4f98c034-b2b8-4a12-935f-a7cb493f1316" />

-   왼쪽 테이블의 모든 행을 포함하고, 오른쪽 테이블에서는 ON절에서 일치하는 행만 가져옵니다.
-   일치하는 행이 없으면 오른쪽 테이블의 값은 NULL로 채워집니다.
-   예시: 주문을 했든 안 했든 모든 고객 정보를 보고 싶을 때, 주문을 한 고객은 주문 정보도 가져오고, 주문이 없는 고객은 주문 정보가 NULL로 표시됩니다.

```
SELECT * FROM customers
LEFT JOIN orders
ON customers.id = orders.customer_id;
```

---

### Right Join: 오른쪽 조인

<img width="238" height="153" alt="image" src="https://github.com/user-attachments/assets/86317ae2-dd7a-4df5-86ce-94bd132c16b5" />

-   왼쪽 조인의 반대
-   오른쪽 테이블의 모든 행을 포함하고, 왼쪽 테이블에서는 ON절에 일치하는 행만 가져옵니다.
-   일치하는 행이 없으면 왼쪽 테이블의 값은 NULL로 채워집니다.
-   예시: employee 테이블과 departments 테이블을 조인하여 소속 직원이 있든 없든 모든 부서 정보를 가져옵니다.

```
SELECT * FROM employees
RIGHT JOIN departments
ON employees.department_id = departments.id;
```

---

### Full Outer Join: 합집합 조인

<img width="256" height="165" alt="image" src="https://github.com/user-attachments/assets/71cfd523-aa04-41a4-a9da-1f2d3f5fefea" />

-   두 테이블의 합집합
-   양쪽 테이블의 모든 행을 가져옵니다. 왼쪽 테이블과 오른쪽 테이블의 모든 데이터를 합칩니다.
-   조건에 맞는 데이터는 결합되고, 어느 한쪽에만 있는 데이터는 다른 쪽 필드가 NULL로 표시됩니다.

---

## 조인의 원리

### 중첩 루프 조인

중첩 for문과 같은 원리로 조건에 맞는 조인을 하는 방법으로

두 테이블을 순차적으로 비교하는 방법입니다.

-   먼저 한 테이블의 모든 행을 순서대로 읽습니다.
-   먼저 읽은 테이블의 각 행에 대해 다른 테이블의 모든 행을 처음부터 끝까지 스캔하면서 조건에 맞는 행을 찾습니다.

```
for 왼쪽 테이블의 모든 행 {
	for 오른쪽 테이블의 모든 행 {
    	if 조인 조건 맞으면 가져오기
    }
}
```

가장 기본적인 조인 방식으로 모든 행을 하나씩 가져와 읽기 때문에 두 테이블의 크기가 작을 때 효율적입니다.

테이블 크기가 커지면 O(N\*M)의 시간 복잡도를 가지므로 성능이 저하될 수 있습니다.

---

### 정렬 병합 조인

두 테이블을 조인 키를 기준으로 먼저 정렬한 후, 조인하는 방식입니다.

다음과 같은 상황에서 주로 사용합니다.

-   조인할 때 사용할 적절한 인덱스가 없거나
-   대용량의 테이블을 조인하거나
-   조인 조건으로 >, < 등 범위 비교 연산자를 사용하거나
-   조인할 데이터가 이미 정렬되어 있거나, 정렬 비용이 전체 조인 비용보다 낮을 때

예시를 살펴봅시다.

구매자 테이블과 주문 테이블이 있고, 두 테이블은 구매자ID로 조인하려 합니다.

구매자ID 컬럼이 같은 구매자와 주문 정보를 결합하고자 합니다.

**1\. 정렬 단계**

두 테이블을 각각 조인 키인 구매자ID를 기준으로 오름차순으로 정렬합니다. 이 과정은 각 테이블을 독립적으로 정렬하는 단계입니다.

-   구매자 테이블: 1번 김철수, 2번 이영희, 3번 박민준, ...
-   주문 테이블**:** 1번 주문 A, 2번 주문 B, 2번 주문 C, 3번 주문 D, ...

**2\. 병합 단계**

정렬된 두 테이블의 **맨 앞 행부터 하나씩 비교**하며 병합을 진행합니다. 마치 두 개의 정렬된 리스트를 하나로 합치는 것과 같습니다.

1.  두 포인터 준비: 구매자 테이블의 첫 번째 행(1번 김철수)과 주문 테이블의 첫 번째 행(1번 주문 A)에 각각 포인터(커서)를 둡니다.
2.  값 비교: 두 포인터가 가리키는 구매자ID를 비교합니다.
    -   구매자ID가 같으면 (1 == 1): 두 행을 조인하여 결과를 만들고, 두 포인터를 모두 다음 행으로 이동시킵니다.
    -   구매자ID가 다르면: 더 작은 값을 가진 쪽의 포인터만 다음 행으로 이동시킵니다. 예를 들어, 구매자ID가 1이고 주문ID가 2라면, 구매자 포인터를 다음 행으로 이동시켜 1번을 건너뛰고 2번과 비교합니다.
3.  **반복:** 이 과정을 한쪽 테이블의 끝에 도달할 때까지 반복합니다.

**장점:**

-   대량의 데이터를 조인할 때, 중첩 루프 조인보다 훨씬 효율적일 수 있습니다.\\\\

**단점:**

-   조인 전에 정렬 비용이 발생합니다. 데이터의 양이 많을수록 정렬에 많은 시간과 자원이 소모될 수 있습니다.
-   정렬 과정이 메모리를 초과하면 디스크 I/O가 발생하여 성능 저하의 원인이 됩니다.

---

### 해시 조인

해시 테이블을 기반으로 조인하는 방법입니다.

한 테이블을 해시 테이블로 만들어 메모리에 저장하고, 다른 테이블의 데이터를 읽으면서 해시 테이블에서 일치하는 값을 찾는 방식입니다.

하나의 테이블이 메모리에 온전히 저장될 수 있다면 보통 중첩 루프 조인보다 더 효율적입니다.

해시 테이블에서 일치하는 값을 찾는 방식이므로 동등 조건(=) 조인에서만 사용 가능합니다.

**1\. 빌드 단계**

-   입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드합니다.
-   두 테이블 중 크기가 더 작은 테이블을 빌드 테이블로 선택합니다.
-   조인에 사용되는 필드가 해시 테이블의 키가 됩니다.

**2\. 프로브 단계**

-   빌드 테이블이 아닌 다른 테이블(프로브 테이블)의 행을 하나씩 읽습니다.
-   각 행의 조인 키에 해시 함수를 적용하여 생성된 해시 값이 해시 테이블에 있는지 탐색합니다.
-   일치하는 값이 있으면 조인하여 결과를 반환합니다.

**장점:**

-   각 테이블을 한 번씩만 읽게 되어 O(N+M)의 시간 복잡도를 가지기 때문에 대량의 데이터를 조인할 때 효율적입니다.
-   빌드 테이블이 메모리에 완전히 올라갈 수 있는 크기일 때 성능이 좋습니다.

---

참고자료

[SQL 기본 문법: JOIN(INNER, OUTER, CROSS, SELF JOIN)](https://hongong.hanbit.co.kr/sql-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95-joininner-outer-cross-self-join/)
